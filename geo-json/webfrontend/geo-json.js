// Generated by CoffeeScript 1.12.7
var ResultMap,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ResultMap = (function(superClass) {
  extend(ResultMap, superClass);

  function ResultMap() {
    this.__getMarkerBySignature = bind(this.__getMarkerBySignature, this);
    return ResultMap.__super__.constructor.apply(this, arguments);
  }

  ResultMap.BUCKET_MAX_OBJECTS = 30;

  ResultMap.MAX_CONCURRENT_BUCKETS_REQUESTS = 10;

  ResultMap.BUCKETS_PER_REQUEST = 500;

  ResultMap.source = "fylr-result-map";

  ResultMap.prototype.initOpts = function() {
    ResultMap.__super__.initOpts.call(this);
    return this.settings = this.getDefaultSettings();
  };

  ResultMap.prototype.init = function() {
    var dfr;
    ResultMap.__super__.init.call(this);
    dfr = new CUI.Deferred();
    this.__pane = new CUI.Pane({
      "class": "ez5-result-table-pane-v2",
      absolute: this._pane_absolute
    });
    this.__loadingPromise = this.__getMapContainer();
    this.__loadingPromise.done((function(_this) {
      return function(map) {
        CUI.dom.append(_this.__pane.center(), map);
        CUI.dom.replace(_this.getResultContainer(), _this.__pane);
        _this.afterInit();
        return dfr.resolve();
      };
    })(this));
    CUI.Events.listen({
      node: this.result_container,
      type: "toolbox",
      call: (function(_this) {
        return function(ev, info) {
          info.tools.push.apply(info.tools, _this.getTools());
          return ev.stopPropagation();
        };
      })(this)
    });
    this.__fitNeeded = true;
    return dfr.promise();
  };

  ResultMap.prototype.afterInit = function() {
    var base;
    return typeof (base = this.getSearch()).disableMapManager === "function" ? base.disableMapManager() : void 0;
  };

  ResultMap.prototype.addGeoBoundingBoxQueryElement = function() {
    var bounds, query;
    bounds = this.__getRequestMapBounds();
    query = new QueryElementGeoBoundingBox({
      boundingBox: bounds
    });
    return this.getSearch().showInSearch(query);
  };

  ResultMap.prototype.getTools = function() {
    var tools;
    tools = [];
    if (this.__map) {
      tools.push(new ToolboxTool({
        name: "map.capture.bound",
        group: "map",
        run: (function(_this) {
          return function(ev) {
            return _this.addGeoBoundingBoxQueryElement();
          };
        })(this)
      }));
    }
    return tools;
  };

  ResultMap.prototype.getName = function() {
    return "map";
  };

  ResultMap.prototype.setSearch = function(_search) {
    this._search = _search;
    ResultMap.__super__.setSearch.call(this, this._search);
    return this;
  };

  ResultMap.prototype.unsetSearch = function() {
    var base;
    if (typeof (base = this.getSearch()).enableMapManager === "function") {
      base.enableMapManager();
    }
    ResultMap.__super__.unsetSearch.call(this);
    return this;
  };

  ResultMap.prototype.updateView = function(form) {
    return ResultMap.__super__.updateView.call(this, form);
  };

  ResultMap.prototype.__getMapOpts = function() {
    var opts;
    opts = {
      defaultSource: ResultMap.source,
      clickable: false,
      zoomToFitAllMarkersOnInit: true,
      onMoveEnd: ResultMap.debounce(this.__onMapMoveEnd.bind(this), 250),
      renderPopup: (function(_this) {
        return function(feature) {
          return _this.__renderPopup(feature);
        };
      })(this),
      onRender: (function(_this) {
        return function(map, features) {
          return _this.__onRenderFeatures(map, features);
        };
      })(this),
      onClick: (function(_this) {
        return function(ev, map) {
          return _this.__onMapClick(ev, map);
        };
      })(this),
      onReady: (function(_this) {
        return function(map) {
          return _this.__onMapReady(map);
        };
      })(this),
      styleFunction: (function(_this) {
        return function(feature) {
          return _this.__styleFunction(feature);
        };
      })(this)
    };
    return opts;
  };

  ResultMap.prototype.__styleFunction = function(feature) {};

  ResultMap.prototype.__onMapReady = function(map) {
    if (!this.__map) {
      this.__map = map;
    }
    return this.__map.resize(true);
  };

  ResultMap.prototype.__getMapContainer = function() {
    var dfr;
    if (this.__map) {
      return CUI.resolvedPromise(this.__map);
    }
    dfr = new CUI.Deferred();
    GeoJsonMap.load(this.__getMapOpts()).done((function(_this) {
      return function(map) {
        _this.__map = map;
        return dfr.resolve(_this.__map);
      };
    })(this)).fail((function(_this) {
      return function() {
        return dfr.reject();
      };
    })(this));
    return dfr;
  };

  ResultMap.prototype.__onMapClick = function(ev, map) {
    var features;
    return;
    features = map.queryRenderedFeatures(ev.point, {
      layers: ['points', 'polygons', 'lines']
    });
    if (CUI.util.isEmpty(features)) {

    }
  };

  ResultMap.prototype.showResult = function(request, data) {
    var bbox, bounding_box_searches, bucket, clusterBuckets, hashBuckets, isCenterInsideBBox, j, k, l, len, len1, len2, map_bounds_search, ref, ref1, ref2, ref3, rejected_count, search, smallBuckets, smallClustersObjects, smallClustersRequest, splitArray;
    if (!request.__map_executed) {
      if (!request.offset || request.offset === 0) {
        this.__fitNeeded = true;
      }
    }
    if ((ref = this.__map) != null ? ref.__mapNotLoadedSchedule((function(_this) {
      return function() {
        return _this.showResult(request, data);
      };
    })(this)) : void 0) {
      return;
    }
    hashBuckets = ((ref1 = data.aggregations) != null ? (ref2 = ref1.hashes) != null ? ref2.buckets : void 0 : void 0) || [];
    if (hashBuckets.length === 0) {
      this.__map.addDataToSource(ResultMap.source, {
        type: "FeatureCollection",
        features: []
      });
      return;
    }
    smallBuckets = [];
    clusterBuckets = [];
    for (j = 0, len = hashBuckets.length; j < len; j++) {
      bucket = hashBuckets[j];
      if (bucket.doc_count > ResultMap.BUCKET_MAX_OBJECTS) {
        clusterBuckets.push(bucket);
      } else if (bucket.doc_count > 0) {
        smallBuckets.push(bucket);
      }
    }
    if (smallBuckets.length > 0) {
      smallClustersRequest = CUI.util.copyObject(request, true);
      ref3 = smallClustersRequest.search;
      for (k = 0, len1 = ref3.length; k < len1; k++) {
        search = ref3[k];
        if (search != null ? search.geo_bounding_box : void 0) {
          smallClustersRequest.search.splice(smallClustersRequest.search.indexOf(search), 1);
        }
      }
      bounding_box_searches = [];
      bbox = this.__getRequestMapBounds();
      isCenterInsideBBox = function(bucket) {
        return bucket.geo_center.lon >= bbox.top_left.lon && bucket.geo_center.lon <= bbox.bottom_right.lon && bucket.geo_center.lat >= bbox.bottom_right.lat && bucket.geo_center.lat <= bbox.top_left.lat;
      };
      rejected_count = 0;
      for (l = 0, len2 = smallBuckets.length; l < len2; l++) {
        bucket = smallBuckets[l];
        if (!isCenterInsideBBox(bucket)) {
          rejected_count++;
          continue;
        }
        bounding_box_searches.push({
          type: "geo_bounding_box",
          field: "_standard.geo.1",
          bool: "should",
          geo_bounding_box: {
            top_left: bucket.key,
            bottom_right: bucket.key
          }
        });
      }
      map_bounds_search = {
        type: "geo_bounding_box",
        field: "_standard.geo.1",
        bool: "must",
        geo_bounding_box: bbox
      };
      smallClustersObjects = [];
      splitArray = function(array, batchSize) {
        var i, n, ref4, ref5, result;
        result = [];
        for (i = n = 0, ref4 = array.length, ref5 = batchSize; ref5 > 0 ? n < ref4 : n > ref4; i = n += ref5) {
          result.push(array.slice(i, i + batchSize));
        }
        return result;
      };
      console.debug("ResultMap.showResult: Zoom level:", this.__map.getZoom(), "Precision:", this.__map.getPrecision(), "Buckets returned:", hashBuckets.length, " Rejected buckets:", rejected_count);
      if (bounding_box_searches.length === 0) {
        bounding_box_searches.push(map_bounds_search);
      }
      CUI.chunkWork.call(this, {
        items: bounding_box_searches,
        chunk_size: ResultMap.MAX_CONCURRENT_BUCKETS_REQUESTS * ResultMap.BUCKETS_PER_REQUEST,
        call: (function(_this) {
          return function(batch) {
            var batches_requests, dfr;
            dfr = new CUI.Deferred();
            batches_requests = [];
            splitArray(batch, ResultMap.BUCKETS_PER_REQUEST).forEach(function(chunk) {
              var s;
              chunk.push(map_bounds_search);
              search = CUI.util.copyObject(smallClustersRequest.search, true);
              search.push({
                type: "complex",
                search: chunk
              });
              s = ez5.api.search({
                data: {
                  debug: "ResultMapSmallClustersRequest"
                },
                json_data: {
                  format: "standard",
                  offset: 0,
                  limit: 1000,
                  objecttypes: smallClustersRequest.objecttypes,
                  search: search
                }
              }).done(function(data) {
                return smallClustersObjects = smallClustersObjects.concat(data.objects);
              });
              return batches_requests.push(s);
            });
            CUI.whenAll(batches_requests).done(function() {
              return dfr.resolve();
            });
            return dfr.promise();
          };
        })(this)
      }).done(((function(_this) {
        return function() {
          var features;
          features = clusterBuckets.map(function(bucket) {
            return {
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [bucket.geo_center.lon, bucket.geo_center.lat]
              },
              properties: {
                doc_count: bucket.doc_count,
                obj_count: bucket.doc_count
              }
            };
          });
          features = _this.__processResultObjects(smallClustersObjects, features);
          features = features.filter(function(f) {
            return f.geometry.type === "Point";
          });
          if (data.count === 1) {
            _this.__fitNeeded = false;
          }
          _this.__map.addDataToSource(ResultMap.source, {
            type: "FeatureCollection",
            features: features
          }, _this.__fitNeeded);
          if (_this.__fitNeeded) {
            return _this.__fitNeeded = false;
          }
        };
      })(this))).fail(((function(_this) {
        return function(err) {
          return console.error(err);
        };
      })(this)));
    }
  };

  ResultMap.prototype.__processResultObjects = function(smallClustersObjects, features) {
    var deleteFeature, featureIndex, j, k, len, len1, objectData, ref, ref1, ro, standardGeoJson, standardsGeoJson;
    if (features == null) {
      features = [];
    }
    this.__resultObjects = [];
    if (!turf) {
      return features;
    }
    for (j = 0, len = smallClustersObjects.length; j < len; j++) {
      objectData = smallClustersObjects[j];
      ro = new ResultObject();
      ro.setData(objectData);
      this.__resultObjects.push(ro);
      standardsGeoJson = ro.getGeoStandard();
      if (standardsGeoJson && standardsGeoJson.length > 0) {
        featureIndex = 0;
        for (k = 0, len1 = standardsGeoJson.length; k < len1; k++) {
          standardGeoJson = standardsGeoJson[k];
          if (!(standardGeoJson != null ? standardGeoJson.features : void 0) && (standardGeoJson != null ? standardGeoJson.coordinates : void 0) && (standardGeoJson != null ? standardGeoJson.type : void 0)) {
            standardGeoJson = {
              type: "FeatureCollection",
              features: [
                {
                  type: "Feature",
                  geometry: {
                    type: standardGeoJson.type,
                    coordinates: standardGeoJson.coordinates
                  },
                  properties: {}
                }
              ]
            };
          } else if ((standardGeoJson != null ? standardGeoJson.type : void 0) === "Feature" && (standardGeoJson != null ? (ref = standardGeoJson.geometry) != null ? ref.type : void 0 : void 0) === "Point") {
            standardGeoJson = {
              type: "FeatureCollection",
              features: [standardGeoJson]
            };
          }
          if ((standardGeoJson != null ? (ref1 = standardGeoJson.features) != null ? ref1.length : void 0 : void 0) > 0) {
            deleteFeature = [];
            turf.featureEach(standardGeoJson, (function(_this) {
              return function(currentFeature, _findex) {
                var center, original_feature;
                if (currentFeature.properties == null) {
                  currentFeature.properties = {};
                }
                deleteFeature = [];
                if (currentFeature.geometry.type !== "Point" && standardGeoJson.features.length > 1) {
                  deleteFeature.push(_findex);
                }
                if (currentFeature.geometry.type !== "Point" && standardGeoJson.features.length === 1) {
                  original_feature = CUI.util.copyObject(currentFeature, true);
                  center = GeoJsonMap.getCenterCoordsForFeature(currentFeature);
                  currentFeature.geometry.type = "Point";
                  currentFeature.geometry.coordinates = center;
                  currentFeature.properties["original_feature"] = original_feature.properties;
                }
                currentFeature.properties.global_object_id = ro.getGlobalObjectId();
                currentFeature.properties.obj_count = 1;
                currentFeature.properties.feature_index = featureIndex;
                return featureIndex++;
              };
            })(this));
            deleteFeature.forEach((function(_this) {
              return function(index) {
                return standardGeoJson.features.splice(index, 1);
              };
            })(this));
            features = features.concat(standardGeoJson.features);
          }
        }
      }
    }
    return features;
  };

  ResultMap.prototype.addToRequest = function(request) {
    var map_size, precision, requestBounds, zoom;
    ResultMap.__super__.addToRequest.call(this, request);
    if (!this.__map) {
      return;
    }
    map_size = this.__map.__map.getSize();
    if (!map_size || map_size[0] === 0 || map_size[1] === 0) {
      return;
    }
    request.limit = 0;
    zoom = this.__map.getZoom();
    precision = this.__map.getPrecision();
    requestBounds = this.__getRequestMapBounds();
    if (!request.aggregations) {
      request.aggregations = {};
    }
    request.aggregations.bounds = {
      type: "geo_bounds",
      field: "_standard.geo.1"
    };
    request.aggregations.hashes = {
      type: "geohash_grid",
      field: "_standard.geo.1",
      precision: precision
    };
    request.search.push({
      type: "geo_bounding_box",
      field: "_standard.geo.1",
      geo_bounding_box: requestBounds
    });
    return this;
  };

  ResultMap.debounce = function(func, wait, immediate) {
    var timeout;
    if (immediate == null) {
      immediate = false;
    }
    timeout = null;
    return function() {
      var args, callNow, context, later;
      context = this;
      args = arguments;
      later = function() {
        timeout = null;
        if (!immediate) {
          return func.apply(context, args);
        }
      };
      callNow = immediate && !timeout;
      if (timeout != null) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(later, wait);
      if (callNow) {
        return func.apply(context, args);
      }
    };
  };

  ResultMap.prototype.__onMapMoveEnd = function() {
    var ref, req;
    req = new Request();
    req.__map_executed = true;
    req.avoid_wait_block = true;
    return (ref = this.getSearch()) != null ? ref.execute(req) : void 0;
  };

  ResultMap.prototype.__getRequestMapBounds = function() {
    var leftLon, mapBounds, normalizeLongitude, ref, rightLon;
    normalizeLongitude = function(lon) {
      var normalizedLon;
      normalizedLon = lon;
      while (normalizedLon < -180) {
        normalizedLon += 360;
      }
      while (normalizedLon > 180) {
        normalizedLon -= 360;
      }
      return normalizedLon;
    };
    mapBounds = this.__map.getBounds();
    if (Math.abs(mapBounds.getNorthWest().lng - mapBounds.getSouthEast().lng) > 360) {
      leftLon = -180;
      rightLon = 180;
    } else {
      leftLon = normalizeLongitude(mapBounds.getNorthWest().lng);
      rightLon = normalizeLongitude(mapBounds.getSouthEast().lng);
    }
    if (leftLon > rightLon) {
      ref = [rightLon, leftLon], leftLon = ref[0], rightLon = ref[1];
    }
    return {
      top_left: {
        lat: mapBounds.getNorthWest().lat,
        lon: leftLon
      },
      bottom_right: {
        lat: mapBounds.getSouthEast().lat,
        lon: rightLon
      }
    };
  };

  ResultMap.prototype.__renderPopup = function(feature) {
    var j, len, ref, ref1, resultObject;
    if (((ref = this.__resultObjects) != null ? ref.length : void 0) > 0) {
      ref1 = this.__resultObjects;
      for (j = 0, len = ref1.length; j < len; j++) {
        resultObject = ref1[j];
        if (resultObject.getGlobalObjectId() === this.__map.getFeatureProperties(feature).global_object_id) {
          return resultObject.renderCardDetail();
        }
      }
    }
    return null;
  };

  ResultMap.prototype.__getMarkerBySignature = function(markersArray, signature) {
    return markersArray.find((function(_this) {
      return function(m) {
        return m.signature === signature;
      };
    })(this)) || null;
  };

  ResultMap.prototype.__onRenderFeatures = function(map, features) {
    var cluster, clusterFeatures, clusterHtml, clusterMarker, countLabel, feature, fn, getFeatureSignature, getSignatureFromCoordinates, i, j, k, l, len, len1, len2, len3, len4, marker, n, o, objectFeatures, p, q, ref, ref1, ref2, ref3, ref4, ref5, renderedCluster, serverCluster, signature;
    objectFeatures = [];
    clusterFeatures = [];
    if (this.__renderedMarkers == null) {
      this.__renderedMarkers = [];
    }
    if (this.__renderedClusters == null) {
      this.__renderedClusters = [];
    }
    getSignatureFromCoordinates = function(coordinates) {
      return coordinates[0] + "-" + coordinates[1];
    };
    getFeatureSignature = (function(_this) {
      return function(feature) {
        return (_this.__map.getFeatureProperties(feature).global_object_id) + "-" + (_this.__map.getFeatureProperties(feature).feature_index);
      };
    })(this);
    ref = this.__renderedMarkers;
    for (j = 0, len = ref.length; j < len; j++) {
      marker = ref[j];
      marker.onScreen = false;
    }
    ref1 = this.__renderedClusters;
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      cluster = ref1[k];
      cluster.onScreen = false;
    }
    for (l = 0, len2 = features.length; l < len2; l++) {
      feature = features[l];
      if ((ref2 = this.__map.getFeatureProperties(feature)) != null ? ref2.doc_count : void 0) {
        clusterFeatures.push(feature);
      }
      if (((ref3 = this.__map.getFeatureProperties(feature)) != null ? ref3.global_object_id : void 0) && !objectFeatures.find((function(_this) {
        return function(f) {
          return getFeatureSignature(f) === getFeatureSignature(feature);
        };
      })(this))) {
        if (this.__map.getFeatureType(feature) === "Point") {
          objectFeatures.push(feature);
        }
      }
      if (this.__map.isFeatureCluster(feature)) {
        if (!clusterFeatures.find((function(_this) {
          return function(f) {
            return _this.__map.getClusterId(f) === _this.__map.getClusterId(feature);
          };
        })(this))) {
          clusterFeatures.push(feature);
        }
      }
    }
    for (n = 0, len3 = clusterFeatures.length; n < len3; n++) {
      cluster = clusterFeatures[n];
      serverCluster = false;
      if (this.__map.getClusterId(cluster) !== null) {
        renderedCluster = this.__renderedClusters.find((function(_this) {
          return function(c) {
            return _this.__map.getClusterId(c.feature) === _this.__map.getClusterId(cluster);
          };
        })(this)) || null;
      } else {
        serverCluster = true;
        renderedCluster = this.__renderedClusters.find((function(_this) {
          return function(c) {
            return getSignatureFromCoordinates(_this.__map.getFeatureCoordinates(c)) === getSignatureFromCoordinates(_this.__map.getFeatureCoordinates(cluster));
          };
        })(this)) || null;
      }
      if (renderedCluster) {
        renderedCluster.onScreen = true;
      } else {
        if (serverCluster) {
          countLabel = new CUI.Label({
            text: "" + cluster.properties.doc_count
          }).DOM;
        } else {
          countLabel = new CUI.Label({
            text: "..."
          }).DOM;
          (function(_this) {
            return (function(countLabel, cluster) {
              return _this.__map.updateClusterLabel(cluster, countLabel);
            });
          })(this)(countLabel, cluster);
        }
        signature = getSignatureFromCoordinates(this.__map.getFeatureCoordinates(cluster));
        clusterHtml = new CUI.dom.div("result-map-cluster");
        clusterHtml.appendChild(countLabel);
        CUI.dom.setAttribute(clusterHtml, "marker-signature", signature);
        clusterMarker = {
          signature: signature,
          feature: cluster,
          coordinates: this.__map.getFeatureCoordinates(cluster),
          html: clusterHtml,
          onScreen: true
        };
        clusterMarker.html.addEventListener("click", (function(_this) {
          return function(ev) {
            marker = _this.__getMarkerBySignature(_this.__renderedClusters, ev.currentTarget.getAttribute("marker-signature"));
            if (marker) {
              _this.__map.zoomToCluster(marker.feature, ResultMap.source);
            }
          };
        })(this));
        this.__map.addMarker(clusterMarker);
        this.__renderedClusters.push(clusterMarker);
      }
    }
    fn = (function(_this) {
      return function(feature) {
        var len5, marker_html, p, ref4, renderedMarker, resultObject, results;
        renderedMarker = _this.__renderedMarkers.find(function(m) {
          return getFeatureSignature(m.feature) === getFeatureSignature(feature);
        }) || null;
        if (renderedMarker) {
          return renderedMarker.onScreen = true;
        } else {
          ref4 = _this.__resultObjects;
          results = [];
          for (p = 0, len5 = ref4.length; p < len5; p++) {
            resultObject = ref4[p];
            if (resultObject.getGlobalObjectId() === _this.__map.getFeatureProperties(feature).global_object_id) {
              marker_html = _this.renderObject(resultObject, getFeatureSignature(feature));
              marker = {
                signature: getFeatureSignature(feature),
                feature: feature,
                coordinates: _this.__map.getFeatureCoordinates(feature),
                html: marker_html,
                onScreen: true,
                anchor: "bottom-center"
              };
              _this.__map.addMarker(marker);
              _this.__renderedMarkers.push(marker);
              break;
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      };
    })(this);
    for (o = 0, len4 = objectFeatures.length; o < len4; o++) {
      feature = objectFeatures[o];
      fn(feature);
    }
    if (this.__renderedClusters.length > 0) {
      for (i = p = ref4 = this.__renderedClusters.length - 1; ref4 <= 0 ? p <= 0 : p >= 0; i = ref4 <= 0 ? ++p : --p) {
        if (!this.__renderedClusters[i].onScreen) {
          this.__map.removeMarker(this.__renderedClusters[i]);
          this.__renderedClusters.splice(i, 1);
        }
      }
    }
    if (this.__renderedMarkers.length > 0) {
      for (i = q = ref5 = this.__renderedMarkers.length - 1; ref5 <= 0 ? q <= 0 : q >= 0; i = ref5 <= 0 ? ++q : --q) {
        if (!this.__renderedMarkers[i].onScreen) {
          this.__map.removeMarker(this.__renderedMarkers[i]);
          this.__renderedMarkers.splice(i, 1);
        }
      }
    }
  };

  ResultMap.prototype.__onMarkerClicked = function(marker) {
    return this.getCollectionSelection().selectAndScrollByGlobalId(this.__map.getFeatureProperties(marker.feature).global_object_id);
  };

  ResultMap.prototype.__getCustomColor = function(object) {
    var color, otname, ref, ref1, ref2, ref3, ref4;
    if ((object == null) || (object.objecttype == null)) {
      return null;
    }
    otname = object.objecttype();
    color = (ref = this.__customColors) != null ? ref[otname] : void 0;
    if (color) {
      return color;
    }
    color = (ref1 = ez5.schema.CURRENT._table_by_name[object.objecttype()]._objecttype.objecttype) != null ? (ref2 = ref1.custom_data) != null ? (ref3 = ref2.webfrontend) != null ? (ref4 = ref3.geo_json) != null ? ref4.marker_color : void 0 : void 0 : void 0 : void 0;
    if (color) {
      if (this.__customColors == null) {
        this.__customColors = {};
      }
      this.__customColors[otname] = color;
      return color;
    }
    return null;
  };

  ResultMap.prototype.__getCustomIcon = function(object) {
    var icon, otname, ref, ref1, ref2, ref3, ref4;
    if ((object == null) || (object.objecttype == null)) {
      return null;
    }
    otname = object.objecttype();
    icon = (ref = this.__customIcons) != null ? ref[otname] : void 0;
    if (icon) {
      return icon;
    }
    icon = (ref1 = ez5.schema.CURRENT._table_by_name[object.objecttype()]._objecttype.objecttype) != null ? (ref2 = ref1.custom_data) != null ? (ref3 = ref2.webfrontend) != null ? (ref4 = ref3.geo_json) != null ? ref4.marker_icon : void 0 : void 0 : void 0 : void 0;
    if (icon) {
      if (this.__customIcons == null) {
        this.__customIcons = {};
      }
      this.__customIcons[otname] = icon;
      return icon;
    }
    return null;
  };

  ResultMap.prototype.renderObject = function(object, signature) {
    var addEvents, addSize, assetElement, assets, customColor, eas_field, icon, idx, j, layout, len, pin, ref, settings, standard, value, values, wrapper;
    settings = this.getSettings();
    addSize = function(element) {
      if (settings["marker_size"] === "sm") {
        return CUI.dom.addClass(element, "size-mini");
      } else if (settings["marker_size"] === "md") {
        return CUI.dom.addClass(element, "size-midi");
      } else if (settings["marker_size"] === "lg") {
        return CUI.dom.addClass(element, "size-maxi");
      }
    };
    addEvents = (function(_this) {
      return function(element) {
        CUI.dom.setAttribute(element, "marker-signature", signature);
        element.addEventListener("click", function(ev) {
          var marker;
          marker = _this.__getMarkerBySignature(_this.__renderedMarkers, ev.currentTarget.getAttribute("marker-signature"));
          if (marker) {
            return _this.__onMarkerClicked(marker);
          }
        });
        element.addEventListener("mouseenter", function(ev) {
          var marker;
          marker = _this.__getMarkerBySignature(_this.__renderedMarkers, ev.currentTarget.getAttribute("marker-signature"));
          if (marker) {
            return _this.__map.showPopup(marker.coordinates, marker.feature, [0, -marker.html.offsetHeight - 5]);
          }
        });
        return element.addEventListener("mouseleave", function(ev) {
          return _this.__map.removePopup();
        });
      };
    })(this);
    switch (settings["marker_format"]) {
      case "standard":
        wrapper = CUI.dom.div("map-marker-image");
        addEvents(wrapper);
        addSize(wrapper);
        standard = object.getStandard(object.data);
        values = ((ref = standard.eas) != null ? ref["1"] : void 0) || [];
        layout = CUI.dom.div("map-card");
        if (!object.getMask().hasStandardEASFields() || CUI.util.isEmpty(values)) {
          layout.appendChild(EAS.getNoAssetInObjecttypePlaceholder().DOM);
          wrapper.appendChild(layout);
          return wrapper;
        }
        eas_field = new EASField();
        assets = [];
        for (idx = j = 0, len = values.length; j < len; idx = ++j) {
          value = values[idx];
          if (!CUI.util.isPlainObject(value)) {
            assets.push(new Asset(eas_field, {
              _error: {
                code: "result.object.asset.faulty_data_from_server"
              }
            }));
            console.error("ResultObject.__render: standard.eas does not contain value", standard, this.getData(), this);
            continue;
          }
          assets.push(new Asset(eas_field, value, values, this.data));
        }
        assetElement = assets[0].getImgElement(null, null, {
          for_print: false,
          show_hourglass: true,
          alt: StandardField.getStandardText(object.data)
        });
        layout.appendChild(assetElement);
        wrapper.appendChild(layout);
        return wrapper;
      default:
        layout = CUI.dom.div("map-marker-pin");
        addEvents(layout);
        addSize(layout);
        pin = '<svg viewBox="0 0 16.32177 20.187037"><path fill="#000000" d="m 8.1359244,0.1192069 c -4.41828,0 -8,4.00258 -8,8.5 0,4.4622001 2.55332,9.3124001 6.5371,11.1744001 0.9286,0.4341 1.9972,0.4341 2.9258,0 3.9837996,-1.862 6.5370996,-6.7122 6.5370996,-11.1744001 0,-4.49742 -3.5817,-8.5 -7.9999996,-8.5 z"/></svg>';
        icon = new CUI.Icon({
          "class": "custom-icon",
          icon: this.__getCustomIcon(object) || "fa-map-marker"
        });
        layout.insertAdjacentHTML('afterbegin', pin);
        customColor = this.__getCustomColor(object);
        if (customColor) {
          CUI.dom.setStyle(layout, {
            "--map-pin-background": customColor
          });
        }
        layout.appendChild(icon.DOM);
        return layout;
    }
  };

  ResultMap.prototype.getDefaultSettings = function() {
    return {
      "marker_format": "icon",
      "marker_size": "sm"
    };
  };

  ResultMap.prototype.saveSettings = function() {};

  ResultMap.prototype.getSettings = function() {
    return this.settings;
  };

  ResultMap.prototype.applySettings = function() {
    this.__renderedMarkers.forEach((function(_this) {
      return function(marker) {
        var newHtml, object;
        if (marker.html) {
          object = _this.__resultObjects.find(function(ro) {
            return ro.getGlobalObjectId() === _this.__map.getFeatureProperties(marker.feature).global_object_id;
          });
          newHtml = _this.renderObject(object, marker.signature);
          marker.html.replaceWith(newHtml);
          marker.html = newHtml;
        }
      };
    })(this));
  };

  return ResultMap;

})(ResultManagerResult);
// Generated by CoffeeScript 1.12.7
var MapSearchManager,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MapSearchManager = (function(superClass) {
  extend(MapSearchManager, superClass);

  function MapSearchManager() {
    return MapSearchManager.__super__.constructor.apply(this, arguments);
  }

  MapSearchManager.SETTINGS_KEY = "search.main.map.settings";

  MapSearchManager.prototype.initOpts = function() {
    MapSearchManager.__super__.initOpts.call(this);
    this.addOpts({
      collection: {
        check: function(v) {
          return v instanceof CollectionSelection;
        }
      }
    });
    this.removeOpt("container");
    this.__linkedToSearch = true;
    return this.settings = ez5.session.getPref(MapSearchManager.SETTINGS_KEY) || this.getDefaultSettings();
  };

  MapSearchManager.prototype.__getMapOpts = function() {
    var opts;
    this._unlinkButton = new CUI.Button({
      icon_inactive: "fa-chain-broken",
      icon_active: "fa-link",
      "switch": true,
      tooltip: {
        text: "Link/Unlink the map from the current search results - Unlink let you explore the map without affecting the search results"
      },
      active: true,
      activate_initial: false,
      group: "upper-right-tools",
      onActivate: (function(_this) {
        return function(btn, flags, ev) {
          return _this.toggleLinkMapFromSearch(true);
        };
      })(this),
      onDeactivate: (function(_this) {
        return function(btn, flags, ev) {
          return _this.toggleLinkMapFromSearch(false);
        };
      })(this)
    });
    opts = MapSearchManager.__super__.__getMapOpts.call(this);
    opts.buttonsUpperLeft = [this.getFilterBoundsButton()];
    opts.buttonsUpperRight = [this._unlinkButton];
    return opts;
  };

  MapSearchManager.prototype.toggleLinkMapFromSearch = function(set) {
    return this.__linkedToSearch = set;
  };

  MapSearchManager.prototype.init = function() {
    var initPromise;
    if (!this.__enabled || this.__initialized) {
      return;
    }
    initPromise = MapSearchManager.__super__.init.call(this);
    initPromise.done((function(_this) {
      return function() {
        if (_this._collection) {
          _this._collection.on({
            type: ["insert", "select", "remove"],
            instance: _this,
            call: function(ev, info) {
              var objects;
              if (ev._type === "remove") {
                objects = [];
              } else {
                objects = info != null ? info.collection_objects : void 0;
              }
              _this.__selectionChanged(objects);
            }
          });
        }
        return _this.__initialized = true;
      };
    })(this));
    return initPromise;
  };

  MapSearchManager.prototype.__onMapReady = function(map) {
    MapSearchManager.__super__.__onMapReady.call(this);
    return this.getSearch().execute();
  };

  MapSearchManager.prototype.afterInit = function() {};

  MapSearchManager.prototype.enable = function() {
    this.__enabled = true;
    return this.init();
  };

  MapSearchManager.prototype.disable = function() {
    this.__enabled = false;
    return this.getSearch().execute();
  };

  MapSearchManager.prototype.addToRequest = function(request) {
    if (!this.__enabled || !this.__initialized) {
      return;
    }
    return MapSearchManager.__super__.addToRequest.call(this, request);
  };

  MapSearchManager.prototype.showResult = function(request, data) {
    if (!this.__enabled) {
      return;
    }
    if (!this.__initialized) {
      return;
    }
    if (!request.__map_executed) {
      this._unlinkButton.setActive(true);
    }
    return MapSearchManager.__super__.showResult.call(this, request, data);
  };

  MapSearchManager.prototype.getResultContainer = function() {
    var base;
    return typeof (base = this.getSearch()).getMapManagerContainer === "function" ? base.getMapManagerContainer() : void 0;
  };

  MapSearchManager.prototype.getFilterBoundsButton = function() {
    if (this.__filterBoudsButton) {
      return this.__filterBoudsButton;
    }
    this.__filterBoudsButton = new CUI.Button({
      icon: "fa-filter",
      tooltip: {
        text: "Adds the current map bounds to the current search as an input query"
      },
      group: "upper-left-tools",
      onClick: (function(_this) {
        return function() {
          return _this.addGeoBoundingBoxQueryElement();
        };
      })(this)
    });
    return this.__filterBoudsButton;
  };

  MapSearchManager.prototype.__hasGeoBoundingBoxFilter = function() {
    var search_input;
    search_input = this.getSearch().getSearchManagers().find((function(_this) {
      return function(sm) {
        return sm instanceof SearchInput;
      };
    })(this));
    if (search_input) {
      return search_input.query.some((function(_this) {
        return function(q) {
          return q instanceof QueryElementGeoBoundingBox;
        };
      })(this));
    }
    return false;
  };

  MapSearchManager.prototype.__onMarkerClicked = function(marker) {
    if (!this.__linkedToSearch) {
      return this.getCollectionSelection().loadInSidebar({
        global_object_id: this.__map.getFeatureProperties(marker.feature).global_object_id
      });
    } else {
      return MapSearchManager.__super__.__onMarkerClicked.call(this, marker);
    }
  };

  MapSearchManager.prototype.__onMapMoveEnd = function() {
    var ref, req, sms;
    req = new Request();
    if (!this.__linkedToSearch) {
      req.exclusive_show = true;
      sms = this.getSearch().getSearchManagers().filter((function(_this) {
        return function(sm) {
          return !(sm instanceof ResultManagerResult);
        };
      })(this));
      sms.push(this);
      req.searchManagers = sms;
    }
    req.__map_executed = true;
    req.avoid_wait_block = true;
    return (ref = this.getSearch()) != null ? ref.execute(req) : void 0;
  };

  MapSearchManager.prototype.getCollectionSelection = function() {
    return this._collection;
  };

  MapSearchManager.prototype.__selectionChanged = function(selected_objects) {
    var gid, gids, i, j, len, len1, marker, ref, same;
    if (!this.__initialized || !this.__enabled || CUI.util.isEmpty(this.__renderedMarkers)) {
      return;
    }
    if (selected_objects.length === 0) {
      if (this._last_selected_objects !== []) {
        ref = this.__renderedMarkers;
        for (i = 0, len = ref.length; i < len; i++) {
          marker = ref[i];
          CUI.dom.removeClass(marker.html, "selected");
        }
      }
      this._last_selected_objects = [];
      return;
    }
    gids = new Set(selected_objects.map(function(object) {
      return object.getGlobalObjectId();
    }));
    gids = new Set(selected_objects.map(function(object) {
      return object.getGlobalObjectId();
    }));
    if (this._last_selected_objects && gids.size === this._last_selected_objects.size) {
      same = true;
      for (j = 0, len1 = gids.length; j < len1; j++) {
        gid = gids[j];
        if (!this._last_selected_objects.has(gid)) {
          same = false;
          break;
        }
      }
      if (same) {
        return;
      }
    }
    this._last_selected_objects = gids;
    this.__renderedMarkers.forEach((function(_this) {
      return function(marker) {
        if (gids.has(_this.__map.getFeatureProperties(marker.feature).global_object_id)) {
          CUI.dom.addClass(marker.html, "selected");
        } else {
          CUI.dom.removeClass(marker.html, "selected");
        }
      };
    })(this));
  };

  MapSearchManager.getManagerButton = function(_opts) {
    var opts;
    if (_opts == null) {
      _opts = {};
    }
    opts = CUI.Element.readOpts(_opts, "MapSearchManager.getManagerButton", {
      onActivate: {
        check: Function
      },
      onDeactivate: {
        check: Function
      }
    });
    return new LocaButton({
      "switch": true,
      ui: "search.main.map.button",
      loca_key: "search.main.map.button",
      "class": "ez5-button-map-manager",
      group: "map",
      onActivate: opts.onActivate,
      onDeactivate: opts.onDeactivate
    });
  };

  MapSearchManager.prototype.getManagerSettingButton = function() {
    this.__mapManagerSettingsBtn = new LocaButton({
      ui: "search.main.map.settings.button",
      "class": "ez5-result-manager-button-options",
      loca_key: "result.manager.button.options",
      group: "map",
      onClick: (function(_this) {
        return function() {
          return _this.getSettingsPopover().show();
        };
      })(this)
    });
    return this.__mapManagerSettingsBtn;
  };

  MapSearchManager.prototype.getSettingsPopover = function(opts) {
    var pop;
    if (opts == null) {
      opts = {};
    }
    return pop = new CUI.Popover({
      element: this.__mapManagerSettingsBtn,
      backdrop: {
        policy: "click"
      },
      "class": "view-select-popover",
      pane: {
        header_left: new LocaLabel({
          loca_key: "search.main.map.settings.title"
        }),
        padded: true,
        content: (function(_this) {
          return function() {
            var data, form;
            data = _this.getSettings();
            form = new CUI.Form({
              data: data,
              fields: [
                {
                  type: CUI.Options,
                  name: "marker_format",
                  form: {
                    label: $$("search.main.map.settings.marker_format")
                  },
                  radio: true,
                  horizontal: false,
                  options: [
                    {
                      value: "standard",
                      text: $$("search.main.map.settings.marker_format.standard")
                    }, {
                      value: "icon",
                      text: $$("search.main.map.settings.marker_format.icon")
                    }
                  ]
                }, {
                  type: CUI.Options,
                  name: "marker_size",
                  form: {
                    label: $$("search.main.map.settings.marker_size")
                  },
                  radio: true,
                  horizontal: false,
                  options: [
                    {
                      value: "sm",
                      text: $$("search.main.map.settings.marker_size.sm")
                    }, {
                      value: "md",
                      text: $$("search.main.map.settings.marker_size.md")
                    }, {
                      value: "lg",
                      text: $$("search.main.map.settings.marker_size.lg")
                    }
                  ]
                }
              ],
              onDataChanged: function() {
                _this.applySettings();
                return pop.changes = true;
              }
            });
            return form.start();
          };
        })(this)
      },
      onHide: (function(_this) {
        return function() {
          if (pop.changes) {
            _this.saveSettings();
          }
          return typeof opts.onHide === "function" ? opts.onHide(pop.changes) : void 0;
        };
      })(this)
    });
  };

  MapSearchManager.prototype.saveSettings = function() {
    return ez5.session.savePref(MapSearchManager.SETTINGS_KEY, this.settings, true);
  };

  return MapSearchManager;

})(ResultMap);
// Generated by CoffeeScript 1.12.7
var GeoJsonMap,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

GeoJsonMap = (function(superClass) {
  extend(GeoJsonMap, superClass);

  GeoJsonMap.prototype.initOpts = function() {
    GeoJsonMap.__super__.initOpts.call(this);
    return this.addOpts({
      renderPopup: {
        check: Function
      },
      onRender: {
        check: Function
      },
      onLoad: {
        check: Function
      },
      searchInput: {
        check: Boolean,
        "default": true
      },
      tilesSelector: {
        check: Boolean,
        "default": true
      },
      defaultSource: {
        check: String,
        "default": "fylr-default"
      },
      styleFunction: {
        check: Function
      }
    });
  };

  GeoJsonMap.prototype.readOpts = function() {
    var defaultStyleIndex, mapSearchInput, mapTilesSelector;
    GeoJsonMap.__super__.readOpts.call(this);
    if (this._searchInput) {
      this.__searchInputData = {};
      mapSearchInput = new MapSearchSelector({
        data: this.__searchInputData,
        name: "mapSearchInput",
        placeholder: "Search for a location",
        onFeatureSelected: (function(_this) {
          return function(feature) {
            return _this.fitData(feature, 0.1);
          };
        })(this)
      });
      if (this._buttonsUpperLeft) {
        this._buttonsUpperLeft.push(mapSearchInput.start());
      } else {
        this._buttonsUpperLeft = [mapSearchInput.start()];
      }
    }
    if (this._tilesSelector && this.__getTilesSelectorOptions().length > 1) {
      this.__tilesSelectorData = {};
      defaultStyleIndex = this.__getDefaultStyleIndex();
      if (defaultStyleIndex != null) {
        this.__tilesSelectorData.mapTileType = defaultStyleIndex;
      }
      mapTilesSelector = new CUI.Select({
        options: (function(_this) {
          return function() {
            return _this.__getTilesSelectorOptions();
          };
        })(this),
        name: "mapTileType",
        data: this.__tilesSelectorData,
        onDataChanged: (function(_this) {
          return function() {
            return _this.__onTilesSelectorChange();
          };
        })(this)
      });
      if (this._buttonsUpperRight) {
        return this._buttonsUpperRight.push(mapTilesSelector.start());
      } else {
        return this._buttonsUpperRight = [mapTilesSelector.start()];
      }
    }
  };

  function GeoJsonMap(opts) {
    GeoJsonMap.__super__.constructor.call(this, opts);
  }

  GeoJsonMap.load = function(opts) {
    var dfr;
    dfr = new CUI.Deferred();
    this.__loadTurf().done((function(_this) {
      return function() {
        switch (GeoJsonMap.getMapType()) {
          case "mapbox":
            return MapboxMap.loadDependencies().done(function() {
              return dfr.resolve(new MapboxMap(opts));
            }).fail(function(err) {
              return dfr.reject(err);
            });
          case "ol":
            return OpenLayersMap.loadDependencies().done(function() {
              return dfr.resolve(new OpenLayersMap(opts));
            }).fail(function(err) {
              return dfr.reject(err);
            });
          default:
            CUI.util.assert(false, "Unknown map type: " + mapType);
            return CUI.rejectedPromise();
        }
      };
    })(this)).fail(dfr.reject);
    return dfr.promise();
  };

  GeoJsonMap.__loadTurf = function() {
    var js_script, promise;
    if (!GeoJsonMap.__turfLoaded) {
      js_script = ez5.pluginManager.getPlugin("geo-json").getBareBaseURL() + "/thirdparty/turf/turf.min.js";
      promise = CUI.loadScript(js_script);
      promise.done((function(_this) {
        return function() {
          return GeoJsonMap.__turfLoaded = true;
        };
      })(this));
      return promise;
    }
    return CUI.resolvedPromise();
  };

  GeoJsonMap.getMapType = function() {
    var ref, ref1, type;
    type = (ref = GeoJsonMap.getConfig()) != null ? (ref1 = ref.map_type) != null ? ref1.select : void 0 : void 0;
    if (CUI.util.isEmpty(type)) {
      type = "ol";
    }
    return type;
  };

  GeoJsonMap.getMapClass = function() {
    var mapType;
    mapType = GeoJsonMap.getMapType();
    switch (mapType) {
      case "mapbox":
        return MapboxMap;
      case "ol":
        return OpenLayersMap;
      default:
        CUI.util.assert(false, "Unknown map type: " + mapType);
        return null;
    }
  };

  GeoJsonMap.getConfig = function() {
    return ez5.session.getBaseConfig("plugin", "geo-json");
  };

  GeoJsonMap.canLoad = function() {
    return CUI.util.assert(false, CUI.util.getObjectClass(this) + ".canLoad: needs to be implemented.");
  };

  GeoJsonMap.prototype.addSource = function(source, data) {
    return CUI.util.assert(false, CUI.util.getObjectClass(this) + ".addSource needs to be implemented.");
  };

  GeoJsonMap.prototype.fitData = function(data, padding, animated) {
    if (animated == null) {
      animated = true;
    }
    return CUI.util.assert(false, CUI.util.getObjectClass(this) + ".fitData needs to be implemented.");
  };

  GeoJsonMap.prototype.__addLayers = function() {
    return CUI.util.assert(false, CUI.util.getObjectClass(this) + ".__addLayers needs to be implemented.");
  };

  GeoJsonMap.prototype.addDataToSource = function(source, data, fit) {
    if (fit == null) {
      fit = false;
    }
    return CUI.util.assert(false, CUI.util.getObjectClass(this) + ".addDataToSource needs to be implemented.");
  };

  GeoJsonMap.prototype.getBounds = function() {
    return CUI.util.assert(false, CUI.util.getObjectClass(this) + ".getBounds needs to be implemented.");
  };

  GeoJsonMap.prototype.getMapCoordsFromEvent = function(ev) {
    return CUI.util.assert(false, CUI.util.getObjectClass(this) + ".getMapCoordsFromEvent needs to be implemented.");
  };

  GeoJsonMap.prototype.getPrecision = function() {
    return CUI.util.assert(false, CUI.util.getObjectClass(this) + ".getPrecision needs to be implemented.");
  };

  GeoJsonMap.prototype.getFeatureProperties = function(feature) {
    return feature.properties;
  };

  GeoJsonMap.prototype.getFeatureGeometry = function(feature) {
    return feature.geometry;
  };

  GeoJsonMap.prototype.getFeatureType = function(feature) {
    return feature.geometry.type;
  };

  GeoJsonMap.prototype.getFeatureCoordinates = function(feature) {
    return feature.geometry.coordinates;
  };

  GeoJsonMap.prototype.isFeatureCluster = function(feature) {
    return false;
  };

  GeoJsonMap.prototype.getClusterId = function(cluster) {
    return null;
  };

  GeoJsonMap.prototype.updateClusterLabel = function(cluster, labelElement) {};

  GeoJsonMap.prototype.zoomToCluster = function(cluster, source) {};

  GeoJsonMap.getCenterCoordsForFeature = function(feature) {
    var center;
    center = turf.center(feature);
    return center.geometry.coordinates;
  };

  GeoJsonMap.flattenArrayOfFeatures = function(elements) {
    var flattenedFeatures, geojson, i, len, ref;
    if (!CUI.util.isArray(elements)) {
      elements = [elements];
    }
    flattenedFeatures = [];
    for (i = 0, len = elements.length; i < len; i++) {
      geojson = elements[i];
      if ((geojson.type != null) && ((ref = geojson.type) !== "Feature" && ref !== "FeatureCollection")) {
        geojson = turf.feature(geojson);
      }
      if (!geojson.features && geojson.type === "Feature") {
        flattenedFeatures.push(geojson);
      } else {
        geojson.features.forEach((function(_this) {
          return function(feature) {
            if (feature.type === "FeatureCollection") {
              return feature.features.forEach(function(nestedFeature) {
                return flattenedFeatures.push(nestedFeature);
              });
            } else {
              return flattenedFeatures.push(feature);
            }
          };
        })(this));
      }
    }
    return turf.featureCollection(flattenedFeatures);
  };

  GeoJsonMap.decomposePolygonToBoundingBoxes = function(polygonFeature, cellSize, units) {
    var bbox, clippedBoxes, grid, ref;
    if (cellSize == null) {
      cellSize = 1;
    }
    if (units == null) {
      units = 'kilometers';
    }
    if ((ref = turf.getType(polygonFeature)) !== 'Polygon' && ref !== 'MultiPolygon') {
      return null;
    }
    bbox = turf.bbox(polygonFeature);
    grid = turf.squareGrid(bbox, cellSize, {
      units: units
    });
    clippedBoxes = [];
    grid.features.forEach(function(cell) {
      var intersection;
      intersection = turf.intersect(cell, polygonFeature);
      if (intersection) {
        return clippedBoxes.push(intersection);
      }
    });
    return turf.featureCollection(clippedBoxes);
  };

  GeoJsonMap.prototype.__getTilesSelectorOptions = function() {
    return [];
  };

  GeoJsonMap.prototype.__getDefaultStyleIndex = function() {
    var i, idx, len, ref, ref1, style, styles;
    styles = (ref = GeoJsonMap.getConfig()) != null ? (ref1 = ref.custom_map_styles) != null ? ref1.styles : void 0 : void 0;
    if (!((styles != null ? styles.length : void 0) > 0)) {
      return null;
    }
    for (idx = i = 0, len = styles.length; i < len; idx = ++i) {
      style = styles[idx];
      if (style["default"] === true) {
        return idx;
      }
    }
    return null;
  };

  GeoJsonMap.prototype.__onTilesSelectorChange = function() {
    return CUI.util.assert(false, CUI.util.getObjectClass(this) + ".__onTilesSelectorChange needs to be implemented.");
  };

  return GeoJsonMap;

})(CUI.Map);
// Generated by CoffeeScript 1.12.7
var OpenLayersMap,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

OpenLayersMap = (function(superClass) {
  extend(OpenLayersMap, superClass);

  OpenLayersMap.prototype.initOpts = function() {
    OpenLayersMap.__super__.initOpts.call(this);
    return this.addOpts({
      zoom: {
        check: "Integer",
        "default": 1
      },
      cluster: {
        check: Boolean,
        "default": true
      },
      drawFeatures: {
        check: Array,
        "default": ["Point", "LineString", "Polygon", "MultiPolygon"]
      }
    });
  };

  function OpenLayersMap(opts) {
    this.__isMapResizing = false;
    OpenLayersMap.__super__.constructor.call(this, opts);
  }

  OpenLayersMap.canLoad = function() {
    return true;
  };

  OpenLayersMap.loadDependencies = function() {
    var basic_dependencies_promise, css_link, dfr, js_script;
    if (!OpenLayersMap.__dependenciesLoaded) {
      dfr = new CUI.Deferred();
      OpenLayersMap.dependenciesPromises = [];
      js_script = 'https://cdn.jsdelivr.net/npm/ol@v10.6.0/dist/ol.js';
      css_link = 'https://cdn.jsdelivr.net/npm/ol@v10.6.0/ol.css';
      OpenLayersMap.dependenciesPromises.push(CUI.loadScript(js_script));
      OpenLayersMap.dependenciesPromises.push(new CUI.CSSLoader().load({
        url: css_link
      }));
      basic_dependencies_promise = CUI.whenAll(OpenLayersMap.dependenciesPromises);
      basic_dependencies_promise.done((function(_this) {
        return function() {
          var ol_mapbox_style, ref;
          if (!CUI.util.isEmpty((ref = GeoJsonMap.getConfig()) != null ? ref.custom_map_styles : void 0)) {
            ol_mapbox_style = 'https://cdn.jsdelivr.net/npm/ol-mapbox-style/dist/olms.js';
            return CUI.loadScript(ol_mapbox_style).done(function() {
              OpenLayersMap.__dependenciesLoaded = true;
              return dfr.resolve();
            });
          } else {
            OpenLayersMap.__dependenciesLoaded = true;
            return dfr.resolve();
          }
        };
      })(this));
      return dfr.promise();
    }
    return CUI.resolvedPromise();
  };

  OpenLayersMap.prototype.__getMapClassName = function() {
    return "cui-openlayers-map";
  };

  OpenLayersMap.prototype.__onReady = function() {
    if (this._centerPosition != null) {
      this.__initCenter = this._centerPosition;
    } else {
      this.__initCenter = this.getCenter();
    }
    if (this._zoom != null) {
      this.__initZoom = this._zoom;
    } else {
      this.__initZoom = this.getZoom();
    }
    this.setCenter();
    this.__applyDefaultStyle();
    return typeof this._onReady === "function" ? this._onReady(this) : void 0;
  };

  OpenLayersMap.prototype.getCenter = function() {
    var center, coords, view;
    view = this.__map.getView();
    center = view.getCenter();
    coords = ol.proj.toLonLat(center, 'EPSG:3857');
    return {
      lat: coords[1],
      lng: coords[0]
    };
  };

  OpenLayersMap.prototype.__buildMap = function() {
    var baseLayer, i, len, mapContainer, ref, slot, source_name, view;
    this.__mapReady = new CUI.Deferred();
    mapContainer = this.get("center");
    view = new ol.View({
      center: ol.proj.fromLonLat([0, 0]),
      zoom: 2,
      projection: 'EPSG:3857',
      extent: ol.proj.get('EPSG:3857').getExtent()
    });
    this.__map = new ol.Map({
      target: mapContainer,
      view: view,
      layers: [],
      controls: [],
      interactions: [new ol.interaction.DragPan(), new ol.interaction.PinchZoom(), new ol.interaction.MouseWheelZoom(), new ol.interaction.DragZoom(), new ol.interaction.DoubleClickZoom(), new ol.interaction.DragRotate(), new ol.interaction.KeyboardPan(), new ol.interaction.KeyboardZoom()]
    });
    baseLayer = new ol.layer.Tile({
      source: new ol.source.OSM()
    });
    this.__map.addLayer(baseLayer);
    this.__vectorSource = new ol.source.Vector({
      features: []
    });
    if (this.__sources == null) {
      this.__sources = {};
    }
    source_name = this._defaultSource || "fylr-default";
    this.__sources[source_name] = this.__vectorSource;
    if (this._cluster) {
      this.__clusterCounter = 0;
      this.__clusterSource = new ol.source.Cluster({
        distance: 50,
        source: this.__vectorSource
      });
      this.__clusterSource.on("addfeature", (function(_this) {
        return function(event) {
          var feature;
          feature = event.feature;
          if (_this.isFeatureCluster(feature)) {
            return feature.set("cluster_id", _this.__clusterCounter++);
          }
        };
      })(this));
      this.__vectorLayer = new ol.layer.Vector({
        source: this.__clusterSource,
        style: function(feature) {
          var size;
          size = feature.get('features').length;
          return new ol.style.Style({
            image: new ol.style.Circle({
              radius: 10,
              stroke: new ol.style.Stroke({
                color: '#fff'
              }),
              fill: new ol.style.Fill({
                color: '#3399CC'
              })
            }),
            text: new ol.style.Text({
              text: size.toString(),
              fill: new ol.style.Fill({
                color: '#fff'
              })
            })
          });
        }
      });
    } else {
      this.__vectorLayer = new ol.layer.Vector({
        source: this.__vectorSource
      });
    }
    this.__map.addLayer(this.__vectorLayer);
    this.__addLayers();
    this.__map.once('rendercomplete', (function(_this) {
      return function() {
        _this.__mapReady.resolve();
        if (_this._onLoad) {
          return _this._onLoad(_this);
        }
      };
    })(this));
    if (this._onRender) {
      this.__map.on('postrender', (function(_this) {
        return function() {
          var extent, feature, features, i, len, visible_features;
          extent = _this.__map.getView().calculateExtent(_this.__map.getSize());
          visible_features = _this.__vectorLayer.getSource().getFeaturesInExtent(extent);
          features = [];
          if (_this._cluster) {
            for (i = 0, len = visible_features.length; i < len; i++) {
              feature = visible_features[i];
              if (_this.isFeatureCluster(feature)) {
                features.push(feature);
              } else {
                features.push(feature.get('features')[0]);
              }
            }
          } else {
            features = visible_features;
          }
          return _this._onRender(_this, features);
        };
      })(this));
    }
    if (this._onClick) {
      this.__map.on('click', (function(_this) {
        return function(ev) {
          var coordinates, feature;
          feature = _this.__map.forEachFeatureAtPixel(ev.pixel, function(feature) {
            return feature;
          });
          coordinates = _this.getMapCoordsFromEvent(ev);
          return _this._onClick(ev, _this, feature, coordinates);
        };
      })(this));
    }
    if (this._onZoomEnd) {
      this.__map.getView().on('change:resolution', (function(_this) {
        return function() {
          if (!_this.__isMapResizing) {
            return _this._onZoomEnd();
          }
        };
      })(this));
    }
    this.__map.on('moveend', (function(_this) {
      return function(args) {
        _this.removePopup();
        if (!_this.__isMapResizing) {
          return _this.__onMoveEnd(args);
        }
      };
    })(this));
    CUI.dom.waitForDOMInsert({
      node: this
    }).done((function(_this) {
      return function() {
        return _this.__onReady();
      };
    })(this));
    this.__detailOverlay = new ol.Overlay({
      element: document.createElement('div'),
      autoPan: false,
      positioning: 'bottom-center',
      offset: [0, -25]
    });
    this.__map.addOverlay(this.__detailOverlay);
    CUI.dom.setStyleOne(CUI.dom.parent(this.__mapTemplate.get("buttons-upper-left")), "pointer-events", "none");
    ref = ["buttons-upper-left", "buttons-upper-right", "buttons-bottom-left", "buttons-bottom-right"];
    for (i = 0, len = ref.length; i < len; i++) {
      slot = ref[i];
      CUI.dom.setStyleOne(this.__mapTemplate.get(slot), "pointer-events", "all");
    }
    CUI.dom.setStyleOne(mapContainer, "padding", "0px");
    return this.__map;
  };

  OpenLayersMap.prototype.isMapReady = function() {
    return this.__mapReady.state() === "resolved";
  };

  OpenLayersMap.prototype.__mapNotLoadedSchedule = function(callback) {
    if (!this.isMapReady()) {
      this.__mapReady.done((function(_this) {
        return function() {
          return callback();
        };
      })(this));
      return true;
    }
    return false;
  };

  OpenLayersMap.prototype.getZoom = function() {
    return this.__map.getView().getZoom();
  };

  OpenLayersMap.prototype.resize = function(triggerAllEvents) {
    if (triggerAllEvents == null) {
      triggerAllEvents = false;
    }
    if (!triggerAllEvents) {
      this.__isMapResizing = true;
      setTimeout((function(_this) {
        return function() {
          return _this.__isMapResizing = false;
        };
      })(this), 500);
    }
    return this.__map.updateSize();
  };

  OpenLayersMap.prototype.zoomIn = function() {
    var view;
    view = this.__map.getView();
    return view.setZoom(view.getZoom() + 1);
  };

  OpenLayersMap.prototype.zoomOut = function() {
    var view;
    view = this.__map.getView();
    return view.setZoom(view.getZoom() - 1);
  };

  OpenLayersMap.prototype.setCenter = function() {
    var view;
    view = this.__map.getView();
    view.setCenter(ol.proj.fromLonLat([this.__initCenter.lng, this.__initCenter.lat]));
    return view.setZoom(this.__initZoom);
  };

  OpenLayersMap.prototype.addSource = function(source, data) {
    var features, format, vectorLayer, vectorSource;
    if (this.__mapNotLoadedSchedule((function(_this) {
      return function() {
        return _this.addSource(source, data);
      };
    })(this))) {
      return;
    }
    if (this.__sources == null) {
      this.__sources = {};
    }
    format = new ol.format.GeoJSON();
    features = format.readFeatures(data, {
      featureProjection: 'EPSG:3857'
    });
    vectorSource = new ol.source.Vector({
      features: features
    });
    this.__sources[source] = vectorSource;
    vectorLayer = new ol.layer.Vector({
      source: vectorSource
    });
    this.__map.addLayer(vectorLayer);
    if (this.__layers == null) {
      this.__layers = {};
    }
    return this.__layers[source] = vectorLayer;
  };

  OpenLayersMap.prototype.getSource = function(source) {
    var ref;
    if (source == null) {
      source = "fylr-default";
    }
    return (ref = this.__sources) != null ? ref[source] : void 0;
  };

  OpenLayersMap.prototype.fitData = function(data, padding, animated, maxZoom) {
    var extent, feature, features, format, i, len, ref, ref1, source;
    if (padding == null) {
      padding = 100;
    }
    if (animated == null) {
      animated = true;
    }
    if (maxZoom == null) {
      maxZoom = 16;
    }
    if (this.__mapNotLoadedSchedule((function(_this) {
      return function() {
        return _this.fitData(data, padding, animated, maxZoom);
      };
    })(this))) {
      return;
    }
    if (!this.__map) {
      return;
    }
    if (CUI.util.isEmpty(data)) {
      source = (ref = this.__sources) != null ? ref["fylr-default"] : void 0;
      if (!source) {
        return;
      }
      features = source.getFeatures();
    } else {
      format = new ol.format.GeoJSON();
      features = format.readFeatures(data, {
        featureProjection: 'EPSG:3857'
      });
    }
    if (!(features.length > 0)) {
      return;
    }
    extent = ol.extent.createEmpty();
    for (i = 0, len = features.length; i < len; i++) {
      feature = features[i];
      ol.extent.extend(extent, feature.getGeometry().getExtent());
    }
    if (extent.some((function(_this) {
      return function(value) {
        return !isFinite(value);
      };
    })(this))) {
      return;
    }
    if (maxZoom === -1) {
      maxZoom = ((ref1 = this.__map.getView()) != null ? ref1.getZoom() : void 0) || 16;
    }
    return this.__map.getView().fit(extent, {
      padding: [padding, padding, padding, padding],
      duration: animated ? 500 : 0,
      maxZoom: maxZoom
    });
  };

  OpenLayersMap.prototype.addDataToSource = function(source, data, fit) {
    var e, extent, feature, features, format, i, len, vectorSource;
    if (fit == null) {
      fit = false;
    }
    if (this.__mapNotLoadedSchedule((function(_this) {
      return function() {
        return _this.addDataToSource(source, data, fit);
      };
    })(this))) {
      return;
    }
    try {
      vectorSource = this.__sources[source];
      if (!vectorSource) {
        return this.addSource(source, data);
      } else {
        format = new ol.format.GeoJSON();
        features = format.readFeatures(data, {
          featureProjection: 'EPSG:3857'
        });
        vectorSource.clear();
        vectorSource.addFeatures(features);
        if (fit) {
          extent = ol.extent.createEmpty();
          for (i = 0, len = features.length; i < len; i++) {
            feature = features[i];
            ol.extent.extend(extent, feature.getGeometry().getExtent());
          }
          if (extent.some((function(_this) {
            return function(value) {
              return !isFinite(value);
            };
          })(this))) {
            return;
          }
          return setTimeout((function(_this) {
            return function() {
              return _this.__map.getView().fit(extent, {
                duration: 500,
                padding: [100, 100, 100, 100],
                maxZoom: 16
              });
            };
          })(this), 500);
        }
      }
    } catch (error) {
      e = error;
      return console.log(e);
    }
  };

  OpenLayersMap.prototype.getDataFromSource = function(source) {
    var features, format, vectorSource;
    vectorSource = this.__sources[source];
    if (!vectorSource) {
      return;
    }
    features = vectorSource.getFeatures();
    format = new ol.format.GeoJSON();
    return format.writeFeaturesObject(features, {
      featureProjection: 'EPSG:3857'
    });
  };

  OpenLayersMap.prototype.addLayer = function(layer) {
    return this.__map.addLayer(layer);
  };

  OpenLayersMap.prototype.__addLayers = function() {
    var ref, ref1, ref2, ref3, styleFunction;
    this.__drawPoints = ((ref = this._drawFeatures) != null ? ref.indexOf('Point') : void 0) >= 0;
    this.__drawLines = ((ref1 = this._drawFeatures) != null ? ref1.indexOf('LineString') : void 0) >= 0;
    this.__drawPolygons = ((ref2 = this._drawFeatures) != null ? ref2.indexOf('Polygon') : void 0) >= 0 || ((ref3 = this._drawFeatures) != null ? ref3.indexOf('MultiPolygon') : void 0) >= 0;
    styleFunction = (function(_this) {
      return function(feature) {
        var geometryType;
        geometryType = feature.getGeometry().getType();
        if (geometryType === 'Point' && _this.__drawPoints) {
          return new ol.style.Style({
            image: new ol.style.Circle({
              radius: 5,
              fill: new ol.style.Fill({
                color: '#FFFFFF'
              }),
              stroke: new ol.style.Stroke({
                color: '#212121',
                width: 3
              })
            })
          });
        } else if (geometryType === 'LineString' && _this.__drawLines) {
          return new ol.style.Style({
            stroke: new ol.style.Stroke({
              color: '#212121',
              width: 3
            })
          });
        } else if ((geometryType === 'Polygon' || geometryType === 'MultiPolygon') && _this.__drawPolygons) {
          return new ol.style.Style({
            fill: new ol.style.Fill({
              color: 'rgba(240, 56, 0, 0.6)'
            }),
            stroke: new ol.style.Stroke({
              color: '#000',
              width: 1
            })
          });
        }
      };
    })(this);
    if (this._styleFunction != null) {
      this.__vectorLayer.setStyle(this._styleFunction);
      return;
    }
    this.__vectorLayer.setStyle(styleFunction);
  };

  OpenLayersMap.prototype.showPopup = function(coordinates, feature, offset, overlay) {
    var content, element;
    if (offset == null) {
      offset = [0, 0];
    }
    if (overlay == null) {
      overlay = this.__detailOverlay;
    }
    content = this._renderPopup(feature);
    if (!content) {
      return;
    }
    element = overlay.getElement();
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
    element.appendChild(content);
    overlay.setOffset(offset);
    return overlay.setPosition(ol.proj.fromLonLat(coordinates));
  };

  OpenLayersMap.prototype.removePopup = function(overlay) {
    if (overlay == null) {
      overlay = this.__detailOverlay;
    }
    return overlay.setPosition(void 0);
  };

  OpenLayersMap.prototype.getBounds = function() {
    var extent, maxCoord, minCoord;
    extent = this.__map.getView().calculateExtent(this.__map.getSize());
    minCoord = ol.proj.toLonLat([extent[0], extent[1]], 'EPSG:3857');
    maxCoord = ol.proj.toLonLat([extent[2], extent[3]], 'EPSG:3857');
    return {
      getNorthWest: function() {
        return {
          lng: minCoord[0],
          lat: maxCoord[1]
        };
      },
      getSouthEast: function() {
        return {
          lng: maxCoord[0],
          lat: minCoord[1]
        };
      }
    };
  };

  OpenLayersMap.prototype.getFeatureProperties = function(feature) {
    return feature.getProperties();
  };

  OpenLayersMap.prototype.getFeatureGeometry = function(feature) {
    return feature.getGeometry();
  };

  OpenLayersMap.prototype.getFeatureType = function(feature) {
    return feature.getGeometry().getType();
  };

  OpenLayersMap.prototype.getFeatureCoordinates = function(feature) {
    return ol.proj.toLonLat(feature.getGeometry().getCoordinates());
  };

  OpenLayersMap.prototype.isFeatureCluster = function(feature) {
    var ref;
    return ((ref = feature.get('features')) != null ? ref.length : void 0) > 1;
  };

  OpenLayersMap.prototype.getClusterId = function(cluster) {
    return cluster.get("cluster_id");
  };

  OpenLayersMap.prototype.updateClusterLabel = function(cluster, labelElement) {
    var f, i, len, ref, size;
    if (cluster.get('doc_count')) {
      size = cluster.get('doc_count');
    } else {
      size = 0;
      ref = cluster.get('features');
      for (i = 0, len = ref.length; i < len; i++) {
        f = ref[i];
        if (f.get('doc_count')) {
          size += f.get('doc_count');
        } else {
          size += 1;
        }
      }
    }
    return CUI.dom.replace(labelElement, new CUI.Label({
      text: "" + size
    }).DOM);
  };

  OpenLayersMap.prototype.zoomToCluster = function(cluster, source) {
    var extent, features;
    features = cluster.get('features') || [];
    if (!(features.length > 0)) {
      return;
    }
    extent = ol.extent.createEmpty();
    features.forEach(function(feature) {
      return ol.extent.extend(extent, feature.getGeometry().getExtent());
    });
    return this.__map.getView().fit(extent, {
      duration: 500,
      padding: [100, 100, 100, 100],
      maxZoom: 16
    });
  };

  OpenLayersMap.prototype.addMarker = function(marker) {
    var anchor, feature, overlay;
    feature = new ol.Feature({
      geometry: new ol.geom.Point(ol.proj.fromLonLat(marker.coordinates))
    });
    anchor = marker.anchor || 'center-center';
    if (marker.html) {
      overlay = new ol.Overlay({
        element: marker.html,
        position: ol.proj.fromLonLat(marker.coordinates),
        positioning: anchor
      });
      this.__map.addOverlay(overlay);
      marker.reference = overlay;
      return marker.html.addEventListener('wheel', (function(_this) {
        return function(event) {
          event.preventDefault();
          return _this.__map.getViewport().dispatchEvent(new WheelEvent('wheel', event));
        };
      })(this));
    } else {
      this.__vectorSource.addFeature(feature);
      return marker.reference = feature;
    }
  };

  OpenLayersMap.prototype.removeMarker = function(marker) {
    if (marker.reference) {
      if (marker.reference instanceof ol.Feature) {
        this.__vectorSource.removeFeature(marker.reference);
      } else if (marker.reference instanceof ol.Overlay) {
        this.__map.removeOverlay(marker.reference);
      }
      return delete marker.reference;
    }
  };

  OpenLayersMap.prototype.__disableEnableZoomButtons = function() {};

  OpenLayersMap.prototype.easeTo = function(coordinates, zoom) {
    var center, view;
    view = this.__map.getView();
    if (!((coordinates != null) && coordinates.length === 2 && typeof zoom === 'number')) {
      return;
    }
    center = ol.proj.fromLonLat(coordinates);
    return view.animate({
      center: center,
      zoom: zoom,
      duration: 500
    });
  };

  OpenLayersMap.prototype.getMapCoordsFromEvent = function(ev) {
    var c;
    if (ev.coordinate == null) {
      if (ev.pixel) {
        c = ol.proj.toLonLat(ev.coordinate = this.__map.getCoordinateFromPixel(ev.pixel));
      }
    } else {
      c = ol.proj.toLonLat(ev.coordinate);
    }
    if (c == null) {
      return null;
    }
    return {
      lng: c[0],
      lat: c[1]
    };
  };

  OpenLayersMap.prototype.getPrecision = function() {
    var precision, zoom;
    zoom = this.getZoom();
    if (zoom >= 13) {
      precision = 8;
    } else if (zoom >= 11) {
      precision = 7;
    } else if (zoom >= 9) {
      precision = 6;
    } else if (zoom >= 7) {
      precision = 5;
    } else if (zoom >= 5) {
      precision = 4;
    } else {
      precision = 3;
    }
    return precision;
  };

  OpenLayersMap.prototype.__getTilesSelectorOptions = function() {
    var def, i, idx, len, ref, ref1, ref2, ref3, ref4, ref5, style;
    def = [
      {
        text: "Default",
        value: "default"
      }, {
        text: "Satellite",
        value: "satellite"
      }
    ];
    if (((ref = GeoJsonMap.getConfig()) != null ? (ref1 = ref.custom_map_styles) != null ? (ref2 = ref1.styles) != null ? ref2.length : void 0 : void 0 : void 0) > 0) {
      ref5 = (ref3 = GeoJsonMap.getConfig()) != null ? (ref4 = ref3.custom_map_styles) != null ? ref4.styles : void 0 : void 0;
      for (idx = i = 0, len = ref5.length; i < len; idx = ++i) {
        style = ref5[idx];
        def.push({
          text: style.name,
          value: idx
        });
      }
    }
    return def;
  };

  OpenLayersMap.prototype.__applyDefaultStyle = function() {
    var defaultStyleIndex;
    if (!(this._tilesSelector && (this.__tilesSelectorData != null))) {
      return;
    }
    defaultStyleIndex = this.__getDefaultStyleIndex();
    if (defaultStyleIndex != null) {
      this.__tilesSelectorData.mapTileType = defaultStyleIndex;
      return this.__onTilesSelectorChange();
    }
  };

  OpenLayersMap.prototype.__onTilesSelectorChange = function() {
    var base_layer, layer, layer_key, properties, ref, ref1, ref2, ref3, ref4, selected_tile, style_json;
    selected_tile = this.__tilesSelectorData.mapTileType;
    if (typeof selected_tile === 'number') {
      style_json = (ref = GeoJsonMap.getConfig()) != null ? (ref1 = ref.custom_map_styles) != null ? (ref2 = ref1.styles) != null ? (ref3 = ref2[selected_tile]) != null ? ref3.value : void 0 : void 0 : void 0 : void 0;
      if (style_json == null) {
        return;
      }
      if (style_json.url != null) {
        if (style_json.properties != null) {
          properties = style_json.properties;
        } else {
          properties = {};
        }
        olms.apply(this.__map, style_json.url, properties);
        return;
      }
      return olms.apply(this.__map, style_json);
    } else {
      this.__map.getLayers().clear();
      if (selected_tile === 'satellite') {
        base_layer = new ol.layer.Tile({
          source: new ol.source.XYZ({
            url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
          })
        });
      } else {
        base_layer = new ol.layer.Tile({
          source: new ol.source.OSM()
        });
      }
      this.__map.addLayer(base_layer);
      this.__map.addLayer(this.__vectorLayer);
      ref4 = this._layers != null;
      for (layer_key in ref4) {
        layer = ref4[layer_key];
        this.__map.addLayer(layer);
      }
      return this.__map.renderSync();
    }
  };

  return OpenLayersMap;

})(GeoJsonMap);
// Generated by CoffeeScript 1.12.7
var GeoJsonFeatureItem,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

GeoJsonFeatureItem = (function(superClass) {
  extend(GeoJsonFeatureItem, superClass);

  function GeoJsonFeatureItem() {
    return GeoJsonFeatureItem.__super__.constructor.apply(this, arguments);
  }

  GeoJsonFeatureItem.prototype.initOpts = function() {
    GeoJsonFeatureItem.__super__.initOpts.call(this);
    return this.addOpts({
      name: {
        check: String
      },
      feature: {
        check: "PlainObject",
        "default": {}
      },
      is_valid: {
        check: Boolean,
        "default": true
      },
      validation_message: {
        check: String
      }
    });
  };

  GeoJsonFeatureItem.prototype.readOpts = function() {
    GeoJsonFeatureItem.__super__.readOpts.call(this);
    return this;
  };

  GeoJsonFeatureItem.prototype.renderContent = function() {
    var content, warningIcon, warningInfo, warningLabel;
    content = GeoJsonColumn.renderFeature(this._feature);
    if (!this._is_valid) {
      content.addClass("ez5-geo-feature-invalid");
      warningIcon = new CUI.Icon({
        icon: "fa-exclamation-triangle",
        "class": "ez5-geo-feature-warning-icon"
      });
      warningLabel = new CUI.Label({
        text: this._validation_message || "Invalid feature for current editor configuration",
        "class": "ez5-geo-feature-warning-text",
        size: "mini"
      });
      warningInfo = new CUI.HorizontalLayout({
        "class": "ez5-geo-feature-warning",
        left: {
          content: warningIcon
        },
        center: {
          content: warningLabel
        }
      });
      content = new CUI.VerticalLayout({
        "class": "ez5-geo-feature-with-warning",
        top: {
          content: content
        },
        bottom: {
          content: warningInfo
        }
      });
    }
    return content;
  };

  return GeoJsonFeatureItem;

})(CUI.ListViewTreeNode);
// Generated by CoffeeScript 1.12.7
var MapEditor,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

MapEditor = (function(superClass) {
  extend(MapEditor, superClass);

  function MapEditor() {
    return MapEditor.__super__.constructor.apply(this, arguments);
  }

  MapEditor.MAP_SOURCE_NAME = "fylr-default";

  MapEditor.MAP_EDITOR_SOURCE_NAME = "fylr-map-editor";

  MapEditor.prototype.initOpts = function() {
    MapEditor.__super__.initOpts.call(this);
    return this.addOpts({
      initial_center: {
        check: "PlainObject"
      },
      initial_zoom: {
        check: "Integer"
      },
      field: {
        mandatory: true,
        check: Field
      },
      data: {
        check: "PlainObject"
      },
      mode: {
        mandatory: true,
        "default": "editor",
        check: ["editor", "detail"]
      },
      done: {
        "default": function() {},
        check: Function
      },
      basic_mode: {
        "default": false,
        check: Boolean
      },
      single_feature: {
        "default": false,
        check: Boolean
      },
      allowed_feature_types: {
        "default": "full",
        check: function(v) {
          return v === "full" || v === "points" || v === "lines" || v === "polygons" || v === "geocoder" || (CUI.util.isArray(v) && v.every(function(type) {
            return type === "points" || type === "lines" || type === "polygons" || type === "geocoder";
          }));
        }
      },
      popover_element: {
        check: function(v) {
          return CUI.util.isElement(v) || CUI.util.isElement(v != null ? v.DOM : void 0);
        }
      }
    });
  };

  MapEditor.prototype.readOpts = function() {
    MapEditor.__super__.readOpts.call(this);
    this.mode = this._mode;
    this.basic_mode = this._basic_mode;
    this.popover_element = this._popover_element;
    if (this.basic_mode) {
      this.single_feature = true;
      this.allowed_feature_types = "points";
    } else {
      this.single_feature = this._single_feature;
      this.allowed_feature_types = this._allowed_feature_types;
    }
    if (CUI.util.isEmpty(this._data)) {
      this._data = GeoJsonColumn.emptyFeatureCollection();
    }
    this.data = this._data || GeoJsonColumn.emptyFeatureCollection();
    this.__features = this.__getFeaturesFromData();
    this.field = this._field;
    this.__done = this._done;
    this.__dataValidation = this.__validateExistingData();
    if (this.basic_mode) {
      this.__tmpl = new CUI.Template({
        name: "map-editor-basic",
        init_flex_handles: true,
        map: {
          tools: true,
          map_view: true
        }
      });
    } else {
      this.__tmpl = new CUI.Template({
        name: "map-editor",
        init_flex_handles: true,
        map: {
          list: true,
          tools: true,
          map_view: true,
          feature_form: true
        }
      });
    }
    if (!this.basic_mode) {
      this.featuresList = this.__tmpl.map.list;
      this.__renderFeaturesList();
      this.__renderFeatureDetail();
    }
    this.mapView = this.__tmpl.map.map_view;
    this.tools = this.__tmpl.map.tools;
    this.init();
    if (this.basic_mode) {
      this.__createPopover();
    } else {
      this.__createModal();
    }
    return CUI.scheduleCallback({
      ms: 100,
      call: (function(_this) {
        return function() {
          return _this.__showDataWarnings(_this.__dataValidation);
        };
      })(this)
    });
  };

  MapEditor.prototype.__createPopover = function() {
    this.popover = new CUI.Popover({
      element: this.popover_element,
      ui: "map.editor.popover",
      "class": "ez5-map-editor-popover ez5-map-editor-popover--basic",
      placement: "w",
      cancel: true,
      onCancel: (function(_this) {
        return function() {};
      })(this),
      pane: {
        content: this.__tmpl,
        header_left: new CUI.Label({
          text: "Map Editor"
        }),
        footer_right: (function(_this) {
          return function() {
            return _this.buttons();
          };
        })(this)
      }
    });
    return this.popover.show();
  };

  MapEditor.prototype.__createModal = function() {
    this.modal = new CUI.Modal({
      ui: "map.editor.modal",
      "class": "ez5-map-editor-modal ez5-map-editor-modal--" + this.mode,
      fill_space: "both",
      cancel: true,
      onCancel: (function(_this) {
        return function() {};
      })(this),
      pane: {
        content: this.__tmpl,
        header_left: new LocaLabel({
          loca_key: "map.editor.title." + this.mode
        }),
        footer_right: (function(_this) {
          return function() {
            return _this.buttons();
          };
        })(this)
      }
    });
    return this.modal.show();
  };

  MapEditor.prototype.init = function() {
    var mapOpts;
    mapOpts = {
      clickable: false,
      cluster: false,
      zoom: this._initial_zoom,
      centerPosition: this._initial_center,
      zoomToFitAllMarkersOnInit: true,
      onClick: (function(_this) {
        return function(ev, map) {
          return _this.__onMapClick(ev, map);
        };
      })(this),
      onReady: (function(_this) {
        return function() {
          _this.__onMapReady();
          _this.__map.resize();
        };
      })(this),
      onLoad: (function(_this) {
        return function() {
          _this.__onMapLoad();
        };
      })(this)
    };
    GeoJsonMap.load(mapOpts).done((function(_this) {
      return function(map) {
        _this.__map = map;
        CUI.dom.append(_this.mapView, _this.__map);
        return _this.renderTools();
      };
    })(this)).fail((function(_this) {
      return function(err) {
        return console.error(err);
      };
    })(this));
  };

  MapEditor.prototype.__showMapContextButtonBar = function(text, btn) {
    var b, btns, i, lbl, len;
    btns = [];
    lbl = new CUI.Label({
      text: text
    });
    btns.push(lbl);
    if (btn) {
      if (btn instanceof Array) {
        for (i = 0, len = btn.length; i < len; i++) {
          b = btn[i];
          btns.push(b);
        }
      } else {
        btns.push(btn);
      }
    }
    this.__mapContextButtonBar = new CUI.Buttonbar({
      "class": "ez5-selected-objects-badge",
      buttons: btns
    });
    return CUI.dom.append(this.__map.__mapTemplate.get("buttons-bottom-center"), this.__mapContextButtonBar);
  };

  MapEditor.prototype.__hideMapContextButtonBar = function() {
    if (this.__mapContextButtonBar) {
      this.__mapContextButtonBar.hide();
      this.__mapContextButtonBar.destroy();
      this.__mapContextButtonBar = null;
    }
  };

  MapEditor.prototype.__onMapLoad = function() {
    var helperFeatures;
    helperFeatures = this.__getGeoJsonFromFeatures([]);
    this.__map.addSource(MapEditor.MAP_EDITOR_SOURCE_NAME, helperFeatures);
  };

  MapEditor.prototype.__isFeatureTypeAllowed = function(featureType) {
    if (this.allowed_feature_types === "full") {
      return true;
    }
    if (CUI.util.isArray(this.allowed_feature_types)) {
      return indexOf.call(this.allowed_feature_types, featureType) >= 0;
    }
    return this.allowed_feature_types === featureType;
  };

  MapEditor.prototype.__getFeatureType = function(feature) {
    var geometryType, ref;
    geometryType = feature != null ? (ref = feature.geometry) != null ? ref.type : void 0 : void 0;
    switch (geometryType) {
      case "Point":
        return "points";
      case "LineString":
        return "lines";
      case "Polygon":
        return "polygons";
      default:
        return null;
    }
  };

  MapEditor.prototype.__validateExistingData = function() {
    var feature, featureType, i, invalidFeatures, len, ref, validFeatures, warnings;
    if (!this.__features || this.__features.length === 0) {
      return {
        valid: true,
        warnings: []
      };
    }
    warnings = [];
    validFeatures = [];
    invalidFeatures = [];
    ref = this.__features;
    for (i = 0, len = ref.length; i < len; i++) {
      feature = ref[i];
      featureType = this.__getFeatureType(feature);
      if (featureType && this.__isFeatureTypeAllowed(featureType)) {
        validFeatures.push(feature);
      } else {
        invalidFeatures.push(feature);
      }
    }
    if (invalidFeatures.length > 0) {
      warnings.push({
        type: "invalid_types",
        count: invalidFeatures.length,
        features: invalidFeatures
      });
    }
    if (this.single_feature && this.__features.length > 1) {
      warnings.push({
        type: "too_many_features",
        count: validFeatures.length,
        features: validFeatures.slice(1)
      });
    }
    return {
      valid: warnings.length === 0,
      warnings: warnings,
      validFeatures: validFeatures,
      invalidFeatures: invalidFeatures
    };
  };

  MapEditor.prototype.__showDataWarnings = function(validation) {
    var allowedTypesText, i, len, ref, warning, warningMessages, warningText;
    if (validation.valid) {
      return;
    }
    warningMessages = [];
    ref = validation.warnings;
    for (i = 0, len = ref.length; i < len; i++) {
      warning = ref[i];
      switch (warning.type) {
        case "invalid_types":
          allowedTypesText = this.allowed_feature_types === "full" ? "all types" : CUI.util.isArray(this.allowed_feature_types) ? this.allowed_feature_types.join(", ") : this.allowed_feature_types;
          warningMessages.push($$("map.editor.warning.invalid_types", {
            count: warning.count,
            allowedTypes: allowedTypesText
          }));
          break;
        case "too_many_features":
          warningMessages.push($$("map.editor.warning.only_one", {
            count: warning.count
          }));
      }
    }
    if (warningMessages.length > 0) {
      warningText = warningMessages.join("\n");
      warningText += "\n\n" + $$("map.editor.warning.extra");
    }
    return CUI.problem({
      text: warningText
    });
  };

  MapEditor.prototype.__hideDataWarnings = function() {
    if (this.__warningBar) {
      this.__warningBar.destroy();
      return this.__warningBar = null;
    }
  };

  MapEditor.prototype.getTools = function() {
    var tools;
    tools = [];
    if (this.__isFeatureTypeAllowed("points")) {
      tools.push(this.__drawPointToolboxTool = new ToolboxTool({
        name: "add-point",
        loca_key: "map.editor.tool.add_point",
        group: "geometry",
        run: (function(_this) {
          return function(ev, toolBtn) {
            return _this.__enableDrawMode("point", toolBtn);
          };
        })(this)
      }));
    }
    if (this.__isFeatureTypeAllowed("polygons")) {
      tools.push(this.__drawPolygonToolboxTool = new ToolboxTool({
        name: "add-polygon",
        loca_key: "map.editor.tool.add_polygon",
        group: "geometry",
        run: (function(_this) {
          return function(ev, toolBtn) {
            return _this.__enableDrawMode("polygon", toolBtn);
          };
        })(this)
      }));
    }
    if (this.__isFeatureTypeAllowed("lines")) {
      tools.push(this.__drawLineToolboxTool = new ToolboxTool({
        name: "add-line",
        loca_key: "map.editor.tool.add_line",
        group: "geometry",
        run: (function(_this) {
          return function(ev, toolBtn) {
            return _this.__enableDrawMode("line", toolBtn);
          };
        })(this)
      }));
    }
    if (this.__isFeatureTypeAllowed("geocoder")) {
      tools.push(this.__geoCoderToolboxTool = new ToolboxTool({
        name: "geocoder",
        loca_key: "map.editor.tool.geocoder",
        group: "geometry",
        run: (function(_this) {
          return function(ev, toolBtn) {
            return _this.__enableDrawMode("geocoder", toolBtn);
          };
        })(this)
      }));
    }
    return tools;
  };

  MapEditor.prototype.renderTools = function() {
    var bb, buttons, i, idx, j, len, len1, ref, ref1, tool;
    if (this.mode === "detail") {
      return;
    }
    buttons = [];
    if (this.toolInstances == null) {
      this.toolInstances = [];
    }
    ref = this.getTools();
    for (i = 0, len = ref.length; i < len; i++) {
      tool = ref[i];
      if (!tool) {
        continue;
      }
      idx = CUI.util.idxInArray(tool, this.toolInstances, function(a, b) {
        return a.getName() === b.getName();
      });
      if (idx === -1) {
        this.toolInstances.push(tool);
      } else {
        tool.destroy();
      }
    }
    ref1 = this.toolInstances;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      tool = ref1[j];
      if (!tool.$btn) {
        (function(_this) {
          return (function(tool) {
            var name, opts;
            opts = tool.getLabelKeys();
            name = tool.getName() || "";
            opts.icon = tool.getIcon();
            opts.size = "big";
            opts.group = tool.getGroup();
            opts.disabled = tool.isDisabled();
            opts.onClick = function(ev, $btn) {
              return tool.run(ev, $btn);
            };
            return tool.$btn = new LocaButton(opts);
          });
        })(this)(tool);
      }
      buttons.push(tool.$btn);
    }
    bb = new CUI.Buttonbar({
      buttons: buttons
    });
    this.__tmpl.replace(bb, "tools");
    return this;
  };

  MapEditor.prototype.buttons = function() {
    this.__doneButton = new LocaButton({
      loca_key: "asset.versions.button.done",
      ui: "map_editor.done.button",
      primary: true,
      onClick: (function(_this) {
        return function(ev) {
          if (_this.basic_mode) {
            _this.popover.destroy();
          } else {
            _this.modal.destroy();
          }
          return _this.__done(_this.__getGeoJsonFromFeatures());
        };
      })(this)
    });
    return [this.__doneButton];
  };

  MapEditor.prototype.__renderFeatureDetail = function() {
    var data, detailContent, featureDetail, form, ref, ref1, ref2, ref3, reverseNameSearchButton, table_coordinates, update_feature_data;
    if (this.basic_mode) {
      return;
    }
    this.__tmpl.map.feature_form.empty();
    detailContent = new CUI.EmptyLabel({
      text: 'Select "Location" from list',
      centered: true,
      markdown: true
    });
    if (this.selectedFeature) {
      this.__selected_feature_saved_data = CUI.util.copyObjectV2(this.selectedFeature, true);
      table_coordinates = [];
      if (this.selectedFeature.geometry.type === "Point") {
        table_coordinates = [
          {
            lng: this.selectedFeature.geometry.coordinates[0],
            lat: this.selectedFeature.geometry.coordinates[1]
          }
        ];
      } else if (this.selectedFeature.geometry.type === "Polygon") {
        if (!CUI.util.isEmpty(this.selectedFeature.geometry.coordinates[0])) {
          table_coordinates = this.selectedFeature.geometry.coordinates[0].map((function(_this) {
            return function(coord) {
              return {
                lng: coord[0],
                lat: coord[1]
              };
            };
          })(this));
        }
      } else if (this.selectedFeature.geometry.type === "LineString") {
        table_coordinates = this.selectedFeature.geometry.coordinates.map((function(_this) {
          return function(coord) {
            return {
              lng: coord[0],
              lat: coord[1]
            };
          };
        })(this));
      }
      data = {
        type: (ref = this.selectedFeature) != null ? (ref1 = ref.geometry) != null ? ref1.type : void 0 : void 0,
        name: (ref2 = this.selectedFeature) != null ? (ref3 = ref2.properties) != null ? ref3.name : void 0 : void 0,
        coordinates: table_coordinates
      };
      reverseNameSearchButton = new CUI.Button({
        icon: "fa-search",
        onClick: (function(_this) {
          return function() {
            var centerCoords, centerFeature, geometry, langs, lat, lon, promise, ref4, xhr;
            geometry = (ref4 = _this.selectedFeature) != null ? ref4.geometry : void 0;
            if (geometry == null) {
              return;
            }
            lat = null;
            lon = null;
            switch (geometry.type) {
              case "Point":
                lon = geometry.coordinates[0];
                lat = geometry.coordinates[1];
                break;
              case "LineString":
              case "Polygon":
              case "MultiLineString":
              case "MultiPolygon":
                centerFeature = turf.center(_this.selectedFeature);
                centerCoords = centerFeature.geometry.coordinates;
                lon = centerCoords[0];
                lat = centerCoords[1];
                break;
              default:
                console.log("Unsupported geometry type for reverse geocoding:", geometry.type);
                return;
            }
            langs = ez5.session.getConfigDatabaseLanguages().map(function(lang) {
              return lang.split('-')[0];
            }).join(",");
            xhr = new CUI.XHR({
              url: "https://nominatim.openstreetmap.org/reverse?format=json&lat=" + lat + "&lon=" + lon + "&accept-language=" + langs
            });
            promise = xhr.start();
            return promise.done(function(reverse_data) {
              var display_name_field, ref5;
              if (reverse_data.name) {
                display_name_field = (ref5 = form.getFieldsByName("name")) != null ? ref5[0] : void 0;
                display_name_field.setValue(reverse_data.name);
                data.name = reverse_data.name;
                update_feature_data();
                return _this.__checkDetailStatus();
              }
            });
          };
        })(this)
      });
      update_feature_data = (function(_this) {
        return function() {
          var base, coordinates;
          if ((base = _this.selectedFeature).properties == null) {
            base.properties = {};
          }
          _this.selectedFeature.properties.name = data.name;
          if (data.type === "Point") {
            coordinates = [data.coordinates[0].lng, data.coordinates[0].lat];
          } else if (data.type === "Polygon") {
            coordinates = data.coordinates.map(function(coord) {
              return [coord.lng, coord.lat];
            });
            coordinates = [coordinates];
          } else if (data.type === "LineString") {
            coordinates = data.coordinates.map(function(coord) {
              return [coord.lng, coord.lat];
            });
          }
          return _this.selectedFeature.geometry.coordinates = coordinates;
        };
      })(this);
      form = new CUI.Form({
        data: data,
        fields: [
          {
            type: CUI.Output,
            name: "type",
            form: {
              label: "Type"
            }
          }, {
            type: CUI.Input,
            name: "name",
            form: {
              label: "Display Name"
            },
            controlElement: reverseNameSearchButton
          }, {
            type: CUI.DataTable,
            name: "coordinates",
            rowMove: true,
            form: {
              label: "Coordinates"
            },
            fields: [
              {
                name: "lat",
                form: {
                  label: "Latitude"
                },
                type: CUI.NumberInput,
                json_number: true,
                decimalpoint: ez5.session.frontend_locale.numbers.decimal,
                separator: ez5.session.frontend_locale.numbers.grouping
              }, {
                name: "lng",
                form: {
                  label: "Longitude"
                },
                type: CUI.NumberInput,
                json_number: true,
                decimalpoint: ez5.session.frontend_locale.numbers.decimal,
                separator: ez5.session.frontend_locale.numbers.grouping
              }
            ]
          }
        ],
        onDataChanged: (function(_this) {
          return function() {
            update_feature_data();
            _this.__checkDetailStatus();
            return _this.__updateFeaturesOnMap();
          };
        })(this)
      });
      detailContent = form.start();
    }
    featureDetail = new CUI.SimplePane({
      "class": "cui-pane--window",
      title: "Detail",
      content: (function(_this) {
        return function() {
          return detailContent;
        };
      })(this),
      footer_right: (function(_this) {
        return function() {
          var cancel_btn;
          if (_this.selectedFeature) {
            _this.__detail_save_btn = new CUI.Button({
              text: "Save",
              disabled: true,
              ui: "map_editor.feature_form.button.save",
              primary: true,
              onClick: function() {
                update_feature_data();
                _this.__renderFeaturesList();
                _this.__updateFeaturesOnMap();
                _this.__selected_feature_saved_data = CUI.util.copyObjectV2(_this.selectedFeature, true);
                return _this.__checkDetailStatus();
              }
            });
            cancel_btn = new CUI.Button({
              text: "Cancel",
              ui: "map_editor.feature_form.button.cancel",
              onClick: function() {
                Object.assign(_this.selectedFeature, _this.__selected_feature_saved_data);
                _this.__selected_feature_saved_data = CUI.util.copyObjectV2(_this.selectedFeature, true);
                _this.__checkDetailStatus();
                _this.__renderFeaturesList();
                return _this.__updateFeaturesOnMap();
              }
            });
            return [cancel_btn, _this.__detail_save_btn];
          }
        };
      })(this)
    });
    this.__tmpl.map.feature_form.append(featureDetail);
  };

  MapEditor.prototype.__checkDetailStatus = function() {
    if (this.selectedFeature) {
      if (CUI.util.isEqual(this.__selected_feature_saved_data, this.selectedFeature)) {
        return this.__detail_save_btn.disable();
      } else {
        return this.__detail_save_btn.enable();
      }
    }
  };

  MapEditor.prototype.__renderFeaturesList = function(selectFeature) {
    var allowedTypesText, buttons, feature, featureType, i, isValid, len, listWrapper, menuItems, node, nodeToSelect, ref, validationMessage;
    if (selectFeature == null) {
      selectFeature = null;
    }
    if (this.basic_mode) {
      return;
    }
    this.featuresList.empty();
    this.featuresTree = new CUI.ListViewTree({
      cols: ["maximize"],
      no_hierarchy: true,
      focusable: false,
      maximize_horizontal: true,
      maximize_vertical: false,
      rowMove: false,
      selectableRows: true,
      onSelect: (function(_this) {
        return function(ev, info) {
          _this.selectedFeature = info.node._feature;
          if (CUI.util.isEmpty(_this.__drawMode)) {
            _this.__map.fitData(_this.selectedFeature, 100, true, -1);
          }
          return _this.__renderFeatureDetail();
        };
      })(this),
      onDeselect: (function(_this) {
        return function() {
          return console.log("Deselect");
        };
      })(this)
    });
    nodeToSelect = null;
    ref = this.__features;
    for (i = 0, len = ref.length; i < len; i++) {
      feature = ref[i];
      featureType = this.__getFeatureType(feature);
      isValid = featureType && this.__isFeatureTypeAllowed(featureType);
      validationMessage = null;
      if (!isValid) {
        if (!featureType) {
          validationMessage = "Unknown or invalid feature type";
        } else {
          allowedTypesText = this.allowed_feature_types === "full" ? "all types" : CUI.util.isArray(this.allowed_feature_types) ? this.allowed_feature_types.join(", ") : this.allowed_feature_types;
          validationMessage = "Feature type '" + featureType + "' not allowed";
        }
      }
      if (this.single_feature && this.__features.indexOf(feature) > 0) {
        isValid = false;
        validationMessage = "Only one feature allowed";
      }
      node = new GeoJsonFeatureItem({
        feature: feature,
        is_valid: isValid,
        validation_message: validationMessage
      });
      this.featuresTree.addNode(node);
      if (selectFeature && feature === selectFeature) {
        nodeToSelect = node;
      }
    }
    menuItems = [];
    if (this.__isFeatureTypeAllowed("points")) {
      menuItems.push({
        text: "Add Point (Draw In Map)",
        onClick: (function(_this) {
          return function(ev) {
            return _this.__enableDrawMode("point", _this.__addButton);
          };
        })(this)
      });
    }
    if (this.__isFeatureTypeAllowed("polygons")) {
      menuItems.push({
        text: "Add Polygon (Draw In Map)",
        onClick: (function(_this) {
          return function(ev) {
            return _this.__enableDrawMode("polygon", _this.__addButton);
          };
        })(this)
      });
    }
    if (this.__isFeatureTypeAllowed("lines")) {
      menuItems.push({
        text: "Add Line (Draw In Map)",
        onClick: (function(_this) {
          return function(ev) {
            return _this.__enableDrawMode("line", _this.__addButton);
          };
        })(this)
      });
    }
    if (menuItems.length > 0 && (!this.single_feature || this.__features.length === 0)) {
      this.__addButton = new LocaButton({
        loca_key: "map.editor.list.edit.button.add",
        ui: "map-editor.add.button",
        group: "one",
        menu: {
          items: menuItems
        }
      });
    }
    this.__removeButton = new LocaButton({
      loca_key: "map.editor.list.button.remove",
      ui: "map-editor.remove.button",
      group: "one",
      onClick: (function(_this) {
        return function(ev) {
          return _this.__removeSelectedFeature();
        };
      })(this)
    });
    buttons = [];
    if (this.__addButton) {
      buttons.push(this.__addButton);
    }
    buttons.push(this.__removeButton);
    this.__feature_buttons = new CUI.Buttonbar({
      buttons: buttons,
      size: "big"
    });
    listWrapper = new CUI.SimplePane({
      "class": "cui-pane--window",
      title: "Locations",
      footer_left: this.__feature_buttons,
      content: (function(_this) {
        return function() {
          return _this.featuresTree.render();
        };
      })(this)
    });
    this.featuresList.append(listWrapper);
    this.featuresTree.root.open();
    if (nodeToSelect) {
      nodeToSelect.select();
    }
  };

  MapEditor.prototype.__getFeaturesFromData = function() {
    var ref;
    return ((ref = this.data) != null ? ref.features : void 0) || [];
  };

  MapEditor.prototype.__getGeoJsonFromFeatures = function(features) {
    if (features == null) {
      features = this.__features;
    }
    return {
      type: "FeatureCollection",
      features: features
    };
  };

  MapEditor.prototype.__addFeatureToList = function(feature) {
    var node;
    if (this.single_feature && this.__features.length > 0) {
      this.__features = [];
      if (!this.basic_mode) {
        this.featuresTree.empty();
      }
    }
    if (!this.basic_mode) {
      node = new GeoJsonFeatureItem({
        feature: feature
      });
      this.featuresTree.addNode(node);
      node.select();
    }
  };

  MapEditor.prototype.__onMapReady = function() {
    var fitZoom, ref, ref1, singleFeature;
    this.__map.addDataToSource(MapEditor.MAP_SOURCE_NAME, this.data);
    if (this.__features.length > 0) {
      fitZoom = this._initial_zoom != null ? this.__initial_zoom : 3;
      if (this.__features.length > 1) {
        fitZoom = 16;
      } else if (this.__features.length === 1) {
        singleFeature = ((ref = this.__features.features) != null ? ref[0] : void 0) || this.__features[0];
        if (((ref1 = singleFeature.geometry) != null ? ref1.type : void 0) !== "Point") {
          fitZoom = 16;
        }
      }
      return this.__map.fitData(null, null, false, fitZoom);
    }
  };

  MapEditor.prototype.__onMapClick = function(ev, map) {};

  MapEditor.prototype.__removeSelectedFeature = function() {
    var idx;
    if (!this.selectedFeature) {
      return;
    }
    idx = CUI.util.idxInArray(this.selectedFeature, this.__features, function(a, b) {
      return a === b;
    });
    if (idx === -1) {
      return;
    }
    this.__features.splice(idx, 1);
    this.__map.addDataToSource(MapEditor.MAP_SOURCE_NAME, {
      type: "FeatureCollection",
      features: this.__features
    });
    this.__renderFeaturesList();
  };

  MapEditor.prototype.__enableDrawMode = function(mode, toolBtn) {
    var lastDrawMode, ref;
    if ((ref = this.__activeToolBtn) != null) {
      ref.deactivate();
    }
    if (!CUI.util.isEmpty(this.__drawMode)) {
      lastDrawMode = this.__drawMode;
      this.__disableDrawMode(this.__drawMode);
      if (lastDrawMode === mode) {
        return;
      }
    }
    this.__drawMode = mode;
    this.__activeToolBtn = toolBtn;
    this.__activeToolBtn.activate();
    switch (mode) {
      case "point":
        this.__enableDrawPointMode();
        break;
      case "polygon":
        this.__enableDrawPolygonMode();
        break;
      case "line":
        this.__enableDrawLineMode();
        break;
      case "geocoder":
        this.__enableGeocoderMode();
        break;
      default:
        throw new Error("Invalid draw mode: " + mode);
    }
  };

  MapEditor.prototype.__disableDrawMode = function(mode) {
    switch (mode) {
      case "point":
        this.__disableDrawPointMode();
        break;
      case "polygon":
        this.__disableDrawPolygonMode();
        break;
      case "line":
        this.__disableDrawLineMode();
        break;
      case "geocoder":
        this.__disableGeocoderMode();
        break;
      default:
        throw new Error("Invalid draw mode: " + mode);
    }
    this.__drawMode = null;
  };

  MapEditor.prototype.__enableDrawPointMode = function() {
    console.log("Enable draw point mode");
    this.__showMapContextButtonBar("Click on the map to add a point", new CUI.Button({
      icon: "fa-check",
      text: "Done",
      size: "mini",
      onClick: (function(_this) {
        return function() {
          return _this.__drawPointToolboxTool.run();
        };
      })(this)
    }));
    this.__drawInteraction = new ol.interaction.Draw({
      source: this.__map.getSource(MapEditor.MAP_EDITOR_SOURCE_NAME),
      type: "Point"
    });
    this.__drawInteraction.on('drawend', (function(_this) {
      return function(evt) {
        var format, geojsonFeature, newOlFeature;
        newOlFeature = evt.feature;
        format = new ol.format.GeoJSON();
        geojsonFeature = format.writeFeatureObject(newOlFeature, {
          featureProjection: 'EPSG:3857',
          dataProjection: 'EPSG:4326'
        });
        if (_this.single_feature) {
          _this.__features = [];
        }
        _this.__features.push(geojsonFeature);
        _this.__updateFeaturesOnMap();
        return _this.__renderFeaturesList(geojsonFeature);
      };
    })(this));
    this.__map.__map.addInteraction(this.__drawInteraction);
  };

  MapEditor.prototype.__disableDrawPointMode = function() {
    console.log("Disable draw point mode");
    this.__hideMapContextButtonBar();
    if (this.__drawInteraction) {
      this.__map.__map.removeInteraction(this.__drawInteraction);
      this.__drawInteraction = null;
    }
    this.__map.addDataToSource(MapEditor.MAP_EDITOR_SOURCE_NAME, this.__getGeoJsonFromFeatures([]));
  };

  MapEditor.prototype.__enableDrawPolygonMode = function() {
    console.log("Enable draw polygon mode");
    this.__showMapContextButtonBar("Click on the map to add points for the area. Press Enter to finish - Use shift for free draw.", new CUI.Button({
      icon: "fa-check",
      text: "Done",
      size: "mini",
      onClick: (function(_this) {
        return function() {
          return _this.__drawPolygonToolboxTool.run();
        };
      })(this)
    }));
    this.__drawInteraction = new ol.interaction.Draw({
      source: this.__map.getSource(MapEditor.MAP_EDITOR_SOURCE_NAME),
      type: "Polygon"
    });
    this.__drawInteraction.on('drawend', (function(_this) {
      return function(evt) {
        var format, geojsonFeature, newOlFeature;
        newOlFeature = evt.feature;
        format = new ol.format.GeoJSON();
        geojsonFeature = format.writeFeatureObject(newOlFeature, {
          featureProjection: 'EPSG:3857',
          dataProjection: 'EPSG:4326'
        });
        if (_this.single_feature) {
          _this.__features = [];
        }
        _this.__features.push(geojsonFeature);
        _this.__updateFeaturesOnMap();
        _this.__renderFeaturesList(geojsonFeature);
        if (_this.__drawInteraction) {
          _this.__map.__map.removeInteraction(_this.__drawInteraction);
          _this.__drawInteraction = null;
        }
        window.removeEventListener("keyup", _this.__drawKeyUpHandler);
        _this.__drawKeyUpHandler = null;
        return _this.__enableSingleFeatureModify(newOlFeature);
      };
    })(this));
    this.__map.__map.addInteraction(this.__drawInteraction);
    this.__drawKeyUpHandler = (function(_this) {
      return function(e) {
        if (e.key === "Enter" && (_this.__drawInteraction != null) && _this.__drawMode === "polygon") {
          return _this.__drawInteraction.finishDrawing();
        }
      };
    })(this);
    window.addEventListener("keyup", this.__drawKeyUpHandler);
  };

  MapEditor.prototype.__disableDrawPolygonMode = function() {
    console.log("Disable draw polygon mode");
    this.__hideMapContextButtonBar();
    if (this.__drawInteraction) {
      this.__map.__map.removeInteraction(this.__drawInteraction);
      this.__drawInteraction = null;
    }
    window.removeEventListener("keyup", this.__drawKeyUpHandler);
    this.__drawKeyUpHandler = null;
    this.__disableSingleFeatureModify();
    this.__map.addDataToSource(MapEditor.MAP_EDITOR_SOURCE_NAME, this.__getGeoJsonFromFeatures([]));
  };

  MapEditor.prototype.__enableSingleFeatureModify = function(olFeature) {
    var featureCollection;
    console.log("Enable single-feature modify mode");
    this.__hideMapContextButtonBar();
    this.__showMapContextButtonBar("Drag the vertices to modify the area. Press Enter to finish.", new CUI.Button({
      icon: "fa-check",
      text: "Done",
      size: "mini",
      onClick: (function(_this) {
        return function() {
          return _this.__drawPolygonToolboxTool.run();
        };
      })(this)
    }));
    featureCollection = new ol.Collection([olFeature]);
    this.__modifyInteraction = new ol.interaction.Modify({
      features: featureCollection
    });
    this.__modifyInteraction.on('modifyend', (function(_this) {
      return function(evt) {
        var format, modifiedFeatures, updatedGeoJson;
        modifiedFeatures = evt.features.getArray();
        if (modifiedFeatures.length > 0) {
          format = new ol.format.GeoJSON();
          updatedGeoJson = format.writeFeatureObject(olFeature, {
            featureProjection: 'EPSG:3857',
            dataProjection: 'EPSG:4326'
          });
          _this.__features[_this.__features.length - 1].geometry = updatedGeoJson.geometry;
          return _this.__updateFeaturesOnMap();
        }
      };
    })(this));
    this.__map.__map.addInteraction(this.__modifyInteraction);
  };

  MapEditor.prototype.__disableSingleFeatureModify = function() {
    console.log("Disable single-feature modify mode");
    this.__hideMapContextButtonBar();
    if (this.__modifyInteraction) {
      this.__map.__map.removeInteraction(this.__modifyInteraction);
      this.__modifyInteraction = null;
    }
  };

  MapEditor.prototype.__enableDrawLineMode = function() {
    console.log("Enable draw line mode");
    this.__showMapContextButtonBar("Click on the map to add points for the line. Press Enter to finish.", new CUI.Button({
      icon: "fa-check",
      text: "Done",
      size: "mini",
      onClick: (function(_this) {
        return function() {
          return _this.__drawLineToolboxTool.run();
        };
      })(this)
    }));
    this.__drawInteraction = new ol.interaction.Draw({
      source: this.__map.getSource(MapEditor.MAP_EDITOR_SOURCE_NAME),
      type: "LineString"
    });
    this.__drawInteraction.on('drawend', (function(_this) {
      return function(evt) {
        var coords, format, geojsonFeature, geometry, newOlFeature;
        newOlFeature = evt.feature;
        geometry = newOlFeature.getGeometry();
        coords = geometry.getCoordinates();
        if (coords.length < 2) {
          _this.__map.getSource(MapEditor.MAP_EDITOR_SOURCE_NAME).removeFeature(newOlFeature);
          console.log("Line must have at least 2 points");
          return;
        }
        format = new ol.format.GeoJSON();
        geojsonFeature = format.writeFeatureObject(newOlFeature, {
          featureProjection: 'EPSG:3857',
          dataProjection: 'EPSG:4326'
        });
        if (_this.single_feature) {
          _this.__features = [];
        }
        _this.__features.push(geojsonFeature);
        _this.__updateFeaturesOnMap();
        return _this.__renderFeaturesList(geojsonFeature);
      };
    })(this));
    this.__map.__map.addInteraction(this.__drawInteraction);
    this.__drawKeyUpHandler = (function(_this) {
      return function(e) {
        if (e.key === "Enter" && (_this.__drawInteraction != null) && _this.__drawMode === "line") {
          return _this.__drawInteraction.finishDrawing();
        }
      };
    })(this);
    window.addEventListener("keyup", this.__drawKeyUpHandler);
  };

  MapEditor.prototype.__disableDrawLineMode = function() {
    console.log("Disable draw line mode");
    this.__hideMapContextButtonBar();
    if (this.__drawInteraction) {
      this.__map.__map.removeInteraction(this.__drawInteraction);
      this.__drawInteraction = null;
    }
    window.removeEventListener("keyup", this.__drawKeyUpHandler);
    this.__drawKeyUpHandler = null;
    this.__map.addDataToSource(MapEditor.MAP_EDITOR_SOURCE_NAME, this.__getGeoJsonFromFeatures([]));
  };

  MapEditor.prototype.__drawLineOnClick = function(ev) {
    var c, coord, i, len, lineHelperFeatures, newFeature, ref;
    coord = this.__map.getMapCoordsFromEvent(ev);
    if (!this.__lineDrawn) {
      this.__lineDrawn = true;
      this.__lineCoords = [];
      this.__lineCoords.push([coord.lng, coord.lat]);
      return;
    }
    this.__lineCoords.push([coord.lng, coord.lat]);
    newFeature = GeoJsonColumn.createLineFeature(this.__lineCoords);
    if (this.__lineCoords.length > 2) {
      this.__features.pop();
    }
    this.__features.push(newFeature);
    this.__updateFeaturesOnMap();
    this.__renderFeaturesList(newFeature);
    lineHelperFeatures = [];
    ref = this.__lineCoords;
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      lineHelperFeatures.push(GeoJsonColumn.createPointFeature(c[0], c[1]));
    }
    lineHelperFeatures.push(GeoJsonColumn.createLineFeature(this.__lineCoords));
    this.__map.addDataToSource(MapEditor.MAP_EDITOR_SOURCE_NAME, this.__getGeoJsonFromFeatures(lineHelperFeatures));
  };

  MapEditor.prototype.__enableGeocoderMode = function() {
    var close_modal, mapSearchSelector, modal;
    close_modal = (function(_this) {
      return function() {
        modal.destroy();
        mapSearchSelector.destroy();
      };
    })(this);
    mapSearchSelector = new MapSearchSelector({
      data: this.data,
      name: "map_search_selector",
      placeholder: "Search to add a location",
      onFeatureSelected: (function(_this) {
        return function(feature) {
          var cancelButton, confirmButton;
          _this.__map.fitData(feature);
          _this.__map.addDataToSource(MapEditor.MAP_EDITOR_SOURCE_NAME, {
            type: "FeatureCollection",
            features: [feature]
          });
          confirmButton = new CUI.Button({
            text: "Confirm",
            icon: "fa-check",
            size: "mini",
            onClick: function() {
              return _this.__confirmGeocoderFeature(feature);
            }
          });
          cancelButton = new CUI.Button({
            text: "Cancel",
            icon: "fa-times",
            size: "mini",
            onClick: function() {
              return _this.__cancelGeocoderFeature();
            }
          });
          _this.__showMapContextButtonBar("Add this location?", [confirmButton, cancelButton]);
          close_modal();
        };
      })(this)
    });
    modal = new CUI.Modal({
      onShow: function() {
        return mapSearchSelector.focus();
      },
      pane: {
        padded: true,
        header_left: new CUI.Label({
          text: "Add a location"
        }),
        content: [mapSearchSelector.start()],
        footer_right: [
          {
            text: CUI.Button.defaults.confirm_cancel,
            onClick: (function(_this) {
              return function() {
                _this.__disableGeocoderMode();
                return close_modal();
              };
            })(this)
          }
        ]
      }
    });
    return modal.show();
  };

  MapEditor.prototype.__disableGeocoderMode = function() {};

  MapEditor.prototype.__confirmGeocoderFeature = function(feature) {
    console.log("Feature confirmed:", feature);
    this.__geoCoderToolboxTool.run();
    if (this.single_feature) {
      this.__features = [];
    }
    this.__features.push(feature);
    this.__updateFeaturesOnMap();
    this.__renderFeaturesList(feature);
    this.__map.addDataToSource(MapEditor.MAP_EDITOR_SOURCE_NAME, {
      type: "FeatureCollection",
      features: []
    });
    this.__hideMapContextButtonBar();
    this.__disableGeocoderMode();
  };

  MapEditor.prototype.__cancelGeocoderFeature = function() {
    console.log("Feature addition canceled");
    this.__geocoderToolboxTool.run();
    this.__map.addDataToSource(MapEditor.MAP_EDITOR_SOURCE_NAME, {
      type: "FeatureCollection",
      features: []
    });
    this.__hideMapContextButtonBar();
    this.__disableGeocoderMode();
  };

  MapEditor.prototype.__updateFeaturesOnMap = function() {
    this.__map.addDataToSource(MapEditor.MAP_SOURCE_NAME, {
      type: "FeatureCollection",
      features: this.__features
    });
  };

  return MapEditor;

})(CUI.Element);
// Generated by CoffeeScript 1.12.7
var GeoJsonDetailMap,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

GeoJsonDetailMap = (function(superClass) {
  extend(GeoJsonDetailMap, superClass);

  function GeoJsonDetailMap() {
    return GeoJsonDetailMap.__super__.constructor.apply(this, arguments);
  }

  GeoJsonDetailMap.prototype.getButtonLocaKey = function() {
    return "map.detail.plugin.button";
  };

  GeoJsonDetailMap.prototype.prefName = function() {
    return "detail_sidebar_show_map";
  };

  GeoJsonDetailMap.prototype.isAvailable = function() {
    var found, mask, ref, ref1, ref2, ref3;
    if ((ref = this._detailSidebar) != null ? (ref1 = ref.object) != null ? ref1.getGeoStandard() : void 0 : void 0) {
      return true;
    }
    mask = (ref2 = this._detailSidebar) != null ? (ref3 = ref2.object) != null ? ref3.mask : void 0 : void 0;
    if (!mask) {
      return false;
    }
    found = false;
    mask.invokeOnFields("detail", true, ((function(_this) {
      return function(f, data) {
        if (f instanceof GeoJsonColumn) {
          return found = true;
        }
      };
    })(this)), this._detailSidebar.object.data[mask.table.name()]);
    return found;
  };

  GeoJsonDetailMap.getConfig = function() {
    return ez5.session.getBaseConfig("plugin", "geo-json");
  };

  GeoJsonDetailMap.prototype.isDisabled = function() {
    var found, mask, ref, ref1, resultObject, standardGeoJson;
    resultObject = this._detailSidebar.object;
    standardGeoJson = resultObject.getGeoStandard();
    if (!CUI.util.isEmpty(standardGeoJson)) {
      return false;
    }
    mask = (ref = this._detailSidebar) != null ? (ref1 = ref.object) != null ? ref1.mask : void 0 : void 0;
    if (!mask) {
      return true;
    }
    found = false;
    mask.invokeOnFields("detail", true, ((function(_this) {
      return function(f, data) {
        if (f instanceof GeoJsonColumn && f.isVisible("detail") && !CUI.util.isEmpty(data != null ? data[f.name()] : void 0)) {
          return found = true;
        }
      };
    })(this)), this._detailSidebar.object.data[mask.table.name()]);
    return !found;
  };

  GeoJsonDetailMap.prototype.renderObject = function() {
    return GeoJsonDetailMap.__super__.renderObject.call(this);
  };

  GeoJsonDetailMap.prototype.showDetail = function() {
    GeoJsonDetailMap.__super__.showDetail.call(this);
    if (this.__map) {
      this.resetMap();
    }
    this.__buildMap();
    return GeoJsonDetailMap.__super__.showDetail.call(this);
  };

  GeoJsonDetailMap.prototype.__buildMap = function(markersOptions, callback) {
    var mapOpts;
    if (callback == null) {
      callback = null;
    }
    mapOpts = {
      clickable: false,
      cluster: false,
      onClick: (function(_this) {
        return function(ev, map) {
          return _this.__onMapClick(ev, map);
        };
      })(this),
      onReady: (function(_this) {
        return function() {
          _this.__onMapReady();
        };
      })(this),
      drawFeatures: ["LineString", "Polygon", "MultiPolygon"]
    };
    return GeoJsonMap.load(mapOpts).done((function(_this) {
      return function(map) {
        _this.__map = map;
        _this._detailSidebar.mainPane.replace(_this.__map, "top");
        return CUI.scheduleCallback({
          ms: 1,
          call: function() {
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      };
    })(this));
  };

  GeoJsonDetailMap.prototype.resetMap = function() {
    var ref;
    if ((ref = this.__map) != null) {
      ref.destroy();
    }
    delete this.__map;
    delete this.__isMapReady;
    CUI.Events.ignore({
      instance: this
    });
  };

  GeoJsonDetailMap.prototype.destroy = function() {
    this.resetMap();
    return GeoJsonDetailMap.__super__.destroy.call(this);
  };

  GeoJsonDetailMap.prototype.__onMapReady = function() {
    var features, fitZoom, geo_json, ref, resultObject, singleFeature;
    this.__map.resize(true);
    resultObject = this._detailSidebar.object;
    features = this.__collectGeoData(resultObject);
    geo_json = GeoJsonMap.flattenArrayOfFeatures(features);
    this.__renderAssets(geo_json);
    this.__renderPoints(geo_json);
    this.__map.addDataToSource(MapEditor.MAP_SOURCE_NAME, geo_json);
    fitZoom = this.__getInitialZoom();
    if (geo_json.features.length > 1) {
      fitZoom = 16;
    } else if (geo_json.features.length === 1) {
      singleFeature = geo_json.features[0];
      if (((ref = singleFeature.geometry) != null ? ref.type : void 0) !== "Point") {
        fitZoom = 16;
      }
    }
    return this.__map.fitData(null, null, false, fitZoom);
  };

  GeoJsonDetailMap.prototype.__onMapClick = function(ev, map) {};

  GeoJsonDetailMap.prototype.__collectGeoData = function(resultObject) {
    var asset, assetFeature, assets, custom_geo_field, custom_geo_fields, features, fieldData, geoData, geoItem, geo_field, geo_fields, gps_location, i, j, k, l, len, len1, len2, len3, ref, ref1, ref2;
    features = [];
    assets = resultObject.getAssetsForBrowser("detail");
    for (i = 0, len = assets.length; i < len; i++) {
      asset = assets[i];
      if (!this.__isAssetEnabledByCustomSetting(asset)) {
        continue;
      }
      if (CUI.util.isEmpty(asset.value.versions)) {
        continue;
      }
      gps_location = (ref = asset.value.technical_metadata) != null ? ref.gps_location : void 0;
      if (gps_location && gps_location.latitude && gps_location.longitude) {
        if (asset.value.versions.small && asset.value.versions.small.width > 0 && asset.value.versions.small.height > 0) {
          assetFeature = {
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: [gps_location.longitude, gps_location.latitude]
            },
            properties: {
              asset: asset
            }
          };
          this.__addFieldInfoToFeature(assetFeature, asset.getField(), "asset");
          features.push(assetFeature);
        }
      }
    }
    geo_fields = [];
    custom_geo_fields = [];
    resultObject.mask.invokeOnFields("detail", true, ((function(_this) {
      return function(f, data) {
        var d, j, k, len1, len2, results, results1;
        if (data && f instanceof GeoJsonColumn) {
          if (CUI.util.isArray(data)) {
            results = [];
            for (j = 0, len1 = data.length; j < len1; j++) {
              d = data[j];
              if (!CUI.util.isEmpty(d)) {
                results.push(geo_fields.push({
                  field: f,
                  data: d[f.name()] || []
                }));
              } else {
                results.push(void 0);
              }
            }
            return results;
          } else {
            return geo_fields.push({
              field: f,
              data: (data != null ? data[f.name()] : void 0) || []
            });
          }
        } else if (f instanceof CustomDataType && (typeof f.supportsGeoStandard === "function" ? f.supportsGeoStandard() : void 0)) {
          if (CUI.util.isArray(data)) {
            results1 = [];
            for (k = 0, len2 = data.length; k < len2; k++) {
              d = data[k];
              if (!CUI.util.isEmpty(d)) {
                results1.push(custom_geo_fields.push({
                  field: f,
                  data: d[f.name()] || []
                }));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          } else {
            return custom_geo_fields.push({
              field: f,
              data: (data != null ? data[f.name()] : void 0) || []
            });
          }
        }
      };
    })(this)), resultObject.data[resultObject.mask.table.name()]);
    for (j = 0, len1 = geo_fields.length; j < len1; j++) {
      geo_field = geo_fields[j];
      if (!CUI.util.isEmpty(geo_field.data)) {
        fieldData = geo_field.data;
        this.__addFieldInfoToGeoData(fieldData, geo_field.field, "geo_field");
        features.push(fieldData);
      }
    }
    for (k = 0, len2 = custom_geo_fields.length; k < len2; k++) {
      custom_geo_field = custom_geo_fields[k];
      if (!CUI.util.isEmpty((ref1 = custom_geo_field.data) != null ? (ref2 = ref1._standard) != null ? ref2.geo : void 0 : void 0)) {
        geoData = custom_geo_field.data._standard.geo;
        if (CUI.util.isArray(geoData)) {
          for (l = 0, len3 = geoData.length; l < len3; l++) {
            geoItem = geoData[l];
            this.__addFieldInfoToGeoData(geoItem, custom_geo_field.field, "custom_geo_field");
          }
          features = features.concat(geoData);
        } else {
          this.__addFieldInfoToGeoData(geoData, custom_geo_field.field, "custom_geo_field");
          features.push(geoData);
        }
      }
    }
    return features;
  };

  GeoJsonDetailMap.prototype.getMarkerIcon = function() {
    var icon, otName, ref, ref1, ref2, ref3;
    otName = this._detailSidebar.object.objecttype();
    icon = (ref = ez5.schema.CURRENT._table_by_name[otName]._objecttype.objecttype) != null ? (ref1 = ref.custom_data) != null ? (ref2 = ref1.webfrontend) != null ? (ref3 = ref2.geo_json) != null ? ref3.marker_icon : void 0 : void 0 : void 0 : void 0;
    if (icon) {
      return icon;
    }
    return "fa-map-marker";
  };

  GeoJsonDetailMap.prototype.getMarkerColor = function() {
    var color, otName, ref, ref1, ref2, ref3;
    otName = this._detailSidebar.object.objecttype();
    color = (ref = ez5.schema.CURRENT._table_by_name[otName]._objecttype.objecttype) != null ? (ref1 = ref.custom_data) != null ? (ref2 = ref1.webfrontend) != null ? (ref3 = ref2.geo_json) != null ? ref3.marker_color : void 0 : void 0 : void 0 : void 0;
    if (color) {
      return color;
    }
    return null;
  };

  GeoJsonDetailMap.prototype.__renderPoints = function(features) {
    turf.featureEach(features, (function(_this) {
      return function(feature) {
        var coordinates, customColor, geometry, icon, layout, marker, pin;
        geometry = feature.geometry;
        if ((geometry != null ? geometry.type : void 0) === "Point") {
          coordinates = geometry.coordinates;
          if (CUI.util.isArray(coordinates) && coordinates.length >= 2) {
            layout = CUI.dom.div("map-marker-pin size-mini");
            pin = '<svg viewBox="0 0 16.32177 20.187037"><path fill="#000000" d="m 8.1359244,0.1192069 c -4.41828,0 -8,4.00258 -8,8.5 0,4.4622001 2.55332,9.3124001 6.5371,11.1744001 0.9286,0.4341 1.9972,0.4341 2.9258,0 3.9837996,-1.862 6.5370996,-6.7122 6.5370996,-11.1744001 0,-4.49742 -3.5817,-8.5 -7.9999996,-8.5 z"/></svg>';
            icon = new CUI.Icon({
              "class": "custom-icon",
              icon: _this.getMarkerIcon()
            });
            layout.insertAdjacentHTML('afterbegin', pin);
            customColor = _this.getMarkerColor();
            if (customColor) {
              CUI.dom.setStyle(layout, {
                "--map-pin-background": customColor
              });
            }
            layout.appendChild(icon.DOM);
            _this.__addTooltipToMarker(layout, feature);
            marker = {
              feature: feature,
              coordinates: coordinates,
              html: layout,
              anchor: "bottom-center"
            };
            return _this.__map.addMarker(marker);
          }
        }
      };
    })(this));
  };

  GeoJsonDetailMap.prototype.__renderAssets = function(features) {
    turf.featureEach(features, (function(_this) {
      return function(feature) {
        var asset, div, image, marker, markerHtml, properties;
        properties = feature.properties;
        if (properties != null ? properties.asset : void 0) {
          asset = properties.asset;
          image = asset.getImgElement(null, "small");
          div = CUI.dom.div("map-marker-image");
          markerHtml = CUI.dom.append(div, image);
          _this.__addTooltipToMarker(markerHtml, feature);
          marker = {
            feature: feature,
            coordinates: feature.geometry.coordinates,
            html: markerHtml
          };
          return _this.__map.addMarker(marker);
        }
      };
    })(this));
  };

  GeoJsonDetailMap.prototype.__addFieldInfoToFeature = function(feature, field, fieldType) {
    if (!feature.properties) {
      feature.properties = {};
    }
    if (field.fullNameLocalized) {
      feature.properties.field_name = field.fullNameLocalized();
    } else if (field instanceof EASField && (field._orginField != null)) {
      feature.properties.field_name = field._originField.fullNameLocalized();
    }
    feature.properties.field_type = fieldType;
  };

  GeoJsonDetailMap.prototype.__addFieldInfoToGeoData = function(geoData, field, fieldType) {
    var feature, i, len, ref;
    if (geoData.type === "FeatureCollection") {
      ref = geoData.features;
      for (i = 0, len = ref.length; i < len; i++) {
        feature = ref[i];
        this.__addFieldInfoToFeature(feature, field, fieldType);
      }
    } else if (geoData.type === "Feature") {
      this.__addFieldInfoToFeature(geoData, field, fieldType);
    }
  };

  GeoJsonDetailMap.prototype.__addTooltipToMarker = function(markerElement, feature) {
    var properties;
    properties = feature.properties;
    if (properties != null ? properties.field_name : void 0) {
      new CUI.Tooltip({
        element: markerElement,
        text: properties.field_name,
        show_ms: 20,
        on_hover: true,
        placement: "n"
      });
    }
  };

  GeoJsonDetailMap.prototype.__isAssetEnabledByCustomSetting = function(asset) {
    var ref, ref1, showInMapSetting;
    showInMapSetting = (ref = asset.getField().FieldSchema) != null ? (ref1 = ref.custom_settings) != null ? ref1.show_in_map : void 0 : void 0;
    return CUI.util.isNull(showInMapSetting) || showInMapSetting;
  };

  GeoJsonDetailMap.prototype.__getInitialZoom = function() {
    var otName, ref, ref1, ref2, ref3, zoom;
    otName = this._detailSidebar.object.objecttype();
    zoom = (ref = ez5.schema.CURRENT._table_by_name[otName]._objecttype.objecttype) != null ? (ref1 = ref.custom_data) != null ? (ref2 = ref1.webfrontend) != null ? (ref3 = ref2.geo_json) != null ? ref3.zoom : void 0 : void 0 : void 0 : void 0;
    if (zoom == null) {
      return 3;
    }
    return zoom;
  };

  return GeoJsonDetailMap;

})(DetailSidebarPlugin);

ez5.session_ready(function() {
  if (GeoJsonMap.getMapClass().canLoad()) {
    return DetailSidebar.plugins.registerPlugin(GeoJsonDetailMap);
  }
});
// Generated by CoffeeScript 1.12.7
var MapFormPopover,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MapFormPopover = (function(superClass) {
  extend(MapFormPopover, superClass);

  MapFormPopover.prototype.initOpts = function() {
    return MapFormPopover.__super__.initOpts.call(this);
  };

  function MapFormPopover(opts) {
    opts.fields = this._getFields();
    MapFormPopover.__super__.constructor.call(this, opts);
  }

  MapFormPopover.prototype._getFields = function() {
    var searchMap;
    searchMap = {
      type: CUI.DataFieldProxy,
      call_others: false,
      name: "search_map",
      element: (function(_this) {
        return function(dataField) {
          var _data, _map, activateCircleTool, activateRectTool, deactivateCircleTool, deactivateRectTool, drawAreaButton, drawCircle, drawCircleButton, drawRect, geoCoderButton, mapOpts, modify, pointAndRadiusButton, point_radius_data, select, selectBB, triggerDataChanged, updateData, vl;
          triggerDataChanged = function() {
            return CUI.Events.trigger({
              node: dataField,
              type: "data-changed"
            });
          };
          _data = dataField.getData() || {};
          if (CUI.util.isEmpty(_data.feature)) {
            _data.feature = {
              type: "FeatureCollection",
              features: []
            };
            _data.type = "polygon_search";
          }
          _map = null;
          drawRect = null;
          drawCircle = null;
          modify = null;
          select = null;
          selectBB = null;
          updateData = function() {
            var f, feature, features, geoJSONFormatter, i, len, ref;
            geoJSONFormatter = new ol.format.GeoJSON();
            features = _map.getSource().getFeatures();
            feature = geoJSONFormatter.writeFeaturesObject(features, {
              dataProjection: 'EPSG:4326',
              featureProjection: 'EPSG:3857'
            });
            ref = feature.features;
            for (i = 0, len = ref.length; i < len; i++) {
              f = ref[i];
              f.properties = {
                bbox: turf.bbox(f)
              };
            }
            Object.assign(_data.feature, feature);
            return triggerDataChanged();
          };
          activateRectTool = function() {
            drawAreaButton.setActive(true);
            drawCircleButton.setActive(false);
            select.getFeatures().clear();
            selectBB.hide();
            _map.__map.removeInteraction(modify);
            _map.__map.removeInteraction(select);
            _map.__map.removeInteraction(drawCircle);
            return _map.__map.addInteraction(drawRect);
          };
          deactivateRectTool = function() {
            drawAreaButton.setActive(false);
            _map.__map.removeInteraction(drawRect);
            _map.__map.addInteraction(modify);
            return setTimeout(function() {
              _map.__map.addInteraction(select);
              select.getFeatures().clear();
              return selectBB.hide();
            }, 500);
          };
          activateCircleTool = function() {
            drawCircleButton.setActive(true);
            drawAreaButton.setActive(false);
            select.getFeatures().clear();
            selectBB.hide();
            _map.__map.removeInteraction(modify);
            _map.__map.removeInteraction(select);
            _map.__map.removeInteraction(drawRect);
            return _map.__map.addInteraction(drawCircle);
          };
          deactivateCircleTool = function() {
            drawCircleButton.setActive(false);
            _map.__map.removeInteraction(drawCircle);
            _map.__map.addInteraction(modify);
            return setTimeout(function() {
              _map.__map.addInteraction(select);
              select.getFeatures().clear();
              return selectBB.hide();
            }, 500);
          };
          drawAreaButton = new CUI.Button({
            text: "Draw Area",
            icon: "fa-pencil-square-o",
            onClick: function() {
              if (drawAreaButton.isActive()) {
                return deactivateRectTool();
              } else {
                return activateRectTool();
              }
            }
          });
          drawCircleButton = new CUI.Button({
            text: "Draw Circle",
            icon: "fa-circle-o",
            onClick: function() {
              if (drawCircleButton.isActive()) {
                return deactivateCircleTool();
              } else {
                return activateCircleTool();
              }
            }
          });
          geoCoderButton = new CUI.Button({
            text: "Geocoder",
            icon: "fa-search",
            onClick: function() {
              return _this.showGeocoderPopover(_map, function(geoJson) {
                _map.addDataToSource("fylr-default", geoJson);
                return updateData();
              });
            }
          });
          point_radius_data = {};
          pointAndRadiusButton = new CUI.Button({
            text: "Point & Radius",
            icon: "fa-dot-circle-o",
            onClick: function() {
              var applyBtn, form, popover;
              form = new CUI.Form({
                data: point_radius_data,
                fields: [
                  {
                    type: CUI.Input,
                    name: "long_lat",
                    placeholder: "e.g. -73.935242, 40.730610",
                    form: {
                      label: "Lon/Lat"
                    }
                  }, {
                    type: CUI.NumberInput,
                    name: "radius",
                    placeholder: "e.g. 1000",
                    form: {
                      label: "Radius"
                    }
                  }, {
                    type: CUI.Select,
                    name: "unit",
                    form: {
                      label: "Unit"
                    },
                    options: [
                      {
                        value: "meters",
                        text: "Meters"
                      }, {
                        value: "kilometers",
                        text: "Kilometers"
                      }, {
                        value: "miles",
                        text: "Miles"
                      }, {
                        value: "feet",
                        text: "Feet"
                      }, {
                        value: "nauticalmiles",
                        text: "Nautical Miles"
                      }
                    ]
                  }
                ]
              });
              applyBtn = new CUI.Button({
                text: "Apply",
                icon: "fa-check",
                onClick: function() {
                  var circle, point, radius, unit;
                  if ((point_radius_data.long_lat != null) && (point_radius_data.radius != null)) {
                    point = GeoJsonColumn.extractCoordinates(point_radius_data.long_lat);
                    radius = parseFloat(point_radius_data.radius);
                    unit = point_radius_data.unit;
                    if (point) {
                      circle = turf.circle([point.geometry.coordinates[0], point.geometry.coordinates[1]], radius, {
                        steps: 64,
                        units: point_radius_data.unit || "kilometers"
                      });
                      _map.addDataToSource("fylr-default", circle, true);
                      point_radius_data = {};
                      updateData();
                    }
                  }
                  return popover.hide();
                }
              });
              popover = new CUI.Popover({
                element: pointAndRadiusButton,
                pane: {
                  content: [form.start(), applyBtn]
                }
              });
              return popover.show();
            }
          });
          vl = new CUI.VerticalLayout({
            maximize_horizontal: true,
            "class": "map-form-popover-vl",
            top: {
              content: [drawAreaButton, drawCircleButton, geoCoderButton, pointAndRadiusButton]
            },
            bottom: {
              content: [
                new CUI.Label({
                  text: "Draw a rectangle or circle in the map to search for items in that area."
                })
              ]
            }
          });
          mapOpts = {
            clickable: false,
            zoomToFitAllMarkersOnInit: true,
            cluster: false,
            searchInput: false
          };
          GeoJsonMap.load(mapOpts).done(function(map) {
            var btns, lbl;
            _map = map;
            drawRect = new ol.interaction.Draw({
              source: _map.getSource(),
              type: 'Circle',
              geometryFunction: ol.interaction.Draw.createBox()
            });
            drawRect.on('drawend', function() {
              return deactivateRectTool();
            });
            drawCircle = new ol.interaction.Draw({
              source: _map.getSource(),
              type: 'Circle'
            });
            drawCircle.on('drawend', function(evt) {
              var circleGeom, newOlFeature, polygonGeom;
              newOlFeature = evt.feature;
              circleGeom = newOlFeature.getGeometry();
              polygonGeom = ol.geom.Polygon.fromCircle(circleGeom, 16);
              newOlFeature.setGeometry(polygonGeom);
              return deactivateCircleTool();
            });
            modify = new ol.interaction.Modify({
              source: _map.getSource()
            });
            select = new ol.interaction.Select();
            _map.__map.addInteraction(select);
            select.on('select', function(e) {
              if (e.selected.length > 0) {
                return selectBB.show();
              } else {
                return selectBB.hide();
              }
            });
            _map.getSource().on('addfeature', function() {
              return updateData();
            });
            _map.getSource().on('removefeature', function() {
              return updateData();
            });
            btns = [];
            lbl = new CUI.Label({
              text: "Selected Area"
            });
            btns.push(lbl);
            btns.push(new CUI.Button({
              icon: "trash",
              size: "mini",
              onClick: function() {
                var featureToDelete, selectedFeatures;
                selectedFeatures = select.getFeatures();
                if (selectedFeatures.getLength() > 0) {
                  featureToDelete = selectedFeatures.item(0);
                  _map.getSource().removeFeature(featureToDelete);
                  selectedFeatures.clear();
                  selectBB.hide();
                  return triggerDataChanged();
                }
              }
            }));
            selectBB = new CUI.Buttonbar({
              "class": "ez5-selected-objects-badge",
              buttons: btns
            });
            _map.resize();
            CUI.dom.append(_map.__mapTemplate.get("buttons-bottom-center"), selectBB);
            selectBB.hide();
            vl.replace(_map, "center");
            _map.addDataToSource("fylr-default", _data.feature, true);
          });
          return vl;
        };
      })(this)
    };
    return [searchMap];
  };

  MapFormPopover.prototype.showGeocoderPopover = function(map, callback) {
    var close_modal, mapSearchSelector, modal;
    close_modal = (function(_this) {
      return function() {
        modal.destroy();
        mapSearchSelector.destroy();
      };
    })(this);
    mapSearchSelector = new MapSearchSelector({
      data: {},
      name: "map_search_selector",
      placeholder: "Search to add a location",
      onFeatureSelected: (function(_this) {
        return function(feature) {
          map.fitData(feature);
          callback(feature);
          close_modal();
        };
      })(this)
    });
    modal = new CUI.Modal({
      onShow: function() {
        return mapSearchSelector.focus();
      },
      pane: {
        padded: true,
        header_left: new CUI.Label({
          text: "Add a location"
        }),
        content: [mapSearchSelector.start()],
        footer_right: [
          {
            text: CUI.Button.defaults.confirm_cancel,
            onClick: (function(_this) {
              return function() {
                return close_modal();
              };
            })(this)
          }
        ]
      }
    });
    return modal.show();
  };

  return MapFormPopover;

})(CUI.FormPopover);
// Generated by CoffeeScript 1.12.7
var SimpleMapEditor,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

SimpleMapEditor = (function(superClass) {
  extend(SimpleMapEditor, superClass);

  function SimpleMapEditor() {
    return SimpleMapEditor.__super__.constructor.apply(this, arguments);
  }

  SimpleMapEditor.MAP_SOURCE_NAME = "fylr-default";

  SimpleMapEditor.prototype.initOpts = function() {
    SimpleMapEditor.__super__.initOpts.call(this);
    return this.addOpts({
      field: {
        mandatory: true,
        check: Field
      },
      data: {
        check: "PlainObject"
      },
      done: {
        "default": function() {},
        check: Function
      }
    });
  };

  SimpleMapEditor.prototype.readOpts = function() {
    SimpleMapEditor.__super__.readOpts.call(this);
    if (CUI.util.isEmpty(this._data)) {
      this._data = GeoJsonColumn.emptyFeatureCollection();
    }
    this.data = this._data || GeoJsonColumn.emptyFeatureCollection();
    this.field = this._field;
    return this.__done = this._done;
  };

  SimpleMapEditor.prototype._getFields = function() {
    var searchMap;
    searchMap = {
      type: CUI.DataFieldProxy,
      call_others: false,
      name: "search_map",
      element: (function(_this) {
        return function(dataField) {
          var _data, _map, coordInputChanged, coordInputs, coordInputs2, mapOpts, triggerDataChanged, updateData, vl;
          triggerDataChanged = function() {
            return CUI.Events.trigger({
              node: dataField,
              type: "data-changed"
            });
          };
          _data = dataField.getData() || {};
          if (CUI.util.isEmpty(_data)) {
            _data = {
              type: "FeatureCollection",
              features: []
            };
          }
          _map = null;
          updateData = function() {
            var coords, feature, features, geoJSONFormatter;
            geoJSONFormatter = new ol.format.GeoJSON();
            features = _map.getSource().getFeatures();
            feature = geoJSONFormatter.writeFeaturesObject(features, {
              dataProjection: 'EPSG:4326',
              featureProjection: 'EPSG:3857'
            });
            Object.assign(_data, feature);
            if (features.length > 0 && features[0].getGeometry().getType() === 'Point') {
              coords = ol.proj.toLonLat(features[0].getGeometry().getCoordinates());
              _this.latInput.setValue(coords[1]);
              _this.lngInput.setValue(coords[0]);
            }
            return triggerDataChanged();
          };
          _this.__coordData = {
            lat: 0,
            lng: 0
          };
          _this.latInput = new CUI.NumberInput({
            name: "lat",
            data: _this.__coordData,
            placeholder: "Latitude",
            decimals: 15,
            onDataChanged: function() {
              return coordInputChanged();
            }
          });
          _this.lngInput = new CUI.NumberInput({
            name: "lng",
            data: _this.__coordData,
            placeholder: "Longitude",
            decimals: 15,
            onDataChanged: function() {
              return coordInputChanged();
            }
          });
          coordInputChanged = function() {
            var lat, lng, point;
            if (!_map) {
              return;
            }
            lat = parseFloat(_this.__coordData.lat);
            lng = parseFloat(_this.__coordData.lng);
            if (isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
              return;
            }
            _map.getSource().clear();
            point = GeoJsonColumn.createPointFeature(lng, lat);
            _map.addDataToSource("fylr-default", point);
            return updateData();
          };
          coordInputs = new CUI.HorizontalLayout({
            left: {
              content: new CUI.Label({
                text: "Lat:"
              }),
              "class": "coord-input-label"
            },
            center: {
              content: _this.latInput.start()
            }
          });
          coordInputs2 = new CUI.HorizontalLayout({
            left: {
              content: new CUI.Label({
                text: "Lng:"
              }),
              "class": "coord-input-label"
            },
            center: {
              content: _this.lngInput.start()
            }
          });
          vl = new CUI.VerticalLayout({
            maximize_horizontal: true,
            "class": "map-form-popover-vl",
            top: {
              content: []
            },
            center: {
              content: _map
            },
            bottom: {
              content: [coordInputs, coordInputs2]
            }
          });
          mapOpts = {
            clickable: false,
            cluster: false,
            zoomToFitAllMarkersOnInit: true,
            onClick: function(ev, map, feature, coordinates) {
              var point;
              map.getSource().clear();
              point = GeoJsonColumn.createPointFeature(coordinates.lng, coordinates.lat);
              map.addDataToSource("fylr-default", point);
              return updateData();
            },
            onReady: function() {
              if (!CUI.util.isEmpty(_data)) {
                return _map.addDataToSource("fylr-default", _data);
              }
            }
          };
          GeoJsonMap.load(mapOpts).done(function(map) {
            _map = map;
            _map.resize();
            vl.replace(_map, "center");
            if (!CUI.util.isEmpty(_this.data)) {
              _map.addDataToSource("fylr-default", _this.data);
            }
          });
          return vl;
        };
      })(this)
    };
    return [searchMap];
  };

  SimpleMapEditor.prototype.getPopoverOpts = function() {
    var opts;
    opts = SimpleMapEditor.__super__.getPopoverOpts.call(this);
    opts.title = $$("geoJsonColumn.simple-map-editor.title");
    opts.pane["class"] = "ez5-simple-map-editor";
    opts.pane.footer_right = new CUI.Button({
      text: $$("base.done"),
      primary: true,
      onClick: (function(_this) {
        return function() {
          var feature;
          feature = _this._data;
          _this.__done(feature);
          return _this.__closePopover();
        };
      })(this)
    });
    return opts;
  };

  return SimpleMapEditor;

})(MapFormPopover);
// Generated by CoffeeScript 1.12.7
var MapSearchSelector,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MapSearchSelector = (function(superClass) {
  extend(MapSearchSelector, superClass);

  function MapSearchSelector() {
    return MapSearchSelector.__super__.constructor.apply(this, arguments);
  }

  MapSearchSelector.prototype.initOpts = function() {
    MapSearchSelector.__super__.initOpts.call(this);
    return this.addOpts({
      onFeatureSelected: {
        check: Function
      },
      placeholder: {
        check: String
      }
    });
  };

  MapSearchSelector.prototype.__getDisplayText = function() {
    return this.__getInputPlaceholder();
  };

  MapSearchSelector.prototype.__search = function() {
    var inputValue, promise, xhr;
    inputValue = this.__input.value;
    xhr = new CUI.XHR({
      url: "https://nominatim.openstreetmap.org/search?format=geojson&polygon_geojson=1&limit=5&q=" + inputValue
    });
    promise = xhr.start();
    promise.done((function(_this) {
      return function(data) {
        return _this.__show(data);
      };
    })(this));
    return promise;
  };

  MapSearchSelector.prototype.render = function() {
    if (this.__isRendered) {
      return;
    }
    MapSearchSelector.__super__.render.call(this);
    this.__autocompletion.addContainer("all");
    this.__searchButton = new CUI.Button({
      appearance: "normal",
      icon: "fa-search",
      onClick: (function(_this) {
        return function() {
          _this.__search();
        };
      })(this)
    });
    return CUI.dom.replace(this.__button, this.__searchButton);
  };

  MapSearchSelector.prototype.__getInputPlaceholder = function() {
    return this._placeholder;
  };

  MapSearchSelector.prototype.__getButtonLocaKey = function() {
    return "pool.field.input.search.button.open_search";
  };

  MapSearchSelector.prototype.__show = function(featureCollection) {
    var feature, fn, i, len, ref;
    this.__autocompletion.emptyContainer();
    if (featureCollection.type !== "FeatureCollection") {
      return;
    }
    ref = featureCollection.features;
    fn = (function(_this) {
      return function(feature) {
        var aitem;
        aitem = _this.__autocompletion.appendItem("all", new CUI.VerticalList({
          content: [feature.properties.display_name]
        }));
        return CUI.Events.listen({
          type: "click",
          node: aitem,
          call: function() {
            if (typeof _this._onFeatureSelected === "function") {
              _this._onFeatureSelected(feature);
            }
            _this.__autocompletion.hide();
          }
        });
      };
    })(this);
    for (i = 0, len = ref.length; i < len; i++) {
      feature = ref[i];
      fn(feature);
    }
    this.__autocompletion.show();
  };

  return MapSearchSelector;

})(SearchSelector);
// Generated by CoffeeScript 1.12.7
var GeoJsonSchemaPlugin,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

GeoJsonSchemaPlugin = (function(superClass) {
  extend(GeoJsonSchemaPlugin, superClass);

  function GeoJsonSchemaPlugin() {
    return GeoJsonSchemaPlugin.__super__.constructor.apply(this, arguments);
  }

  GeoJsonSchemaPlugin.prototype.getCustomSettings = function(data) {
    var fields, pData, ref;
    if ((data != null ? (ref = data.column) != null ? ref.type : void 0 : void 0) !== "geo_json") {
      return [];
    }
    if (!ez5.session.getCapability("geo_support")) {
      return [];
    }
    if (!data.custom_settings["geo-json"]) {
      data.custom_settings["geo-json"] = {};
    }
    pData = data.custom_settings["geo-json"];
    if (pData.allow_points_feature == null) {
      pData.allow_points_feature = true;
    }
    if (pData.allow_lines_feature == null) {
      pData.allow_lines_feature = true;
    }
    if (pData.allow_polygons_feature == null) {
      pData.allow_polygons_feature = true;
    }
    if (pData.allow_geocoder == null) {
      pData.allow_geocoder = true;
    }
    if (pData.allow_multiple_features == null) {
      pData.allow_multiple_features = true;
    }
    fields = [
      {
        type: CUI.Checkbox,
        name: "allow_multiple_features",
        data: pData,
        form: {
          label: "Support Feature Collections"
        }
      }, {
        type: CUI.Checkbox,
        name: "allow_points_feature",
        data: pData,
        form: {
          label: "Support Points"
        }
      }, {
        type: CUI.Checkbox,
        name: "allow_lines_feature",
        data: pData,
        form: {
          label: "Support Lines"
        }
      }, {
        type: CUI.Checkbox,
        name: "allow_polygons_feature",
        data: pData,
        form: {
          label: "Support Polygons"
        }
      }, {
        type: CUI.Checkbox,
        name: "allow_geocoder",
        data: pData,
        form: {
          label: "Support Geocoder"
        }
      }
    ];
    return fields;
  };

  GeoJsonSchemaPlugin.prototype.getCustomSettingsLabel = function(data) {
    var ref;
    if ((data != null ? (ref = data.column) != null ? ref.type : void 0 : void 0) !== "geo_json") {
      return;
    }
    if (!ez5.session.getCapability("geo_support")) {
      return;
    }
    return "GeoJson Editor Settings";
  };

  GeoJsonSchemaPlugin.prototype.getCustomSettingsDisplay = function(data) {
    return [];
  };

  GeoJsonSchemaPlugin.prototype.getName = function() {
    return "geo-json";
  };

  return GeoJsonSchemaPlugin;

})(SchemaPlugin);

Schema.registerPlugin(new GeoJsonSchemaPlugin());
// Generated by CoffeeScript 1.12.7
var MapConfigurationEditor,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MapConfigurationEditor = (function(superClass) {
  extend(MapConfigurationEditor, superClass);

  MapConfigurationEditor.prototype.initOpts = function() {
    MapConfigurationEditor.__super__.initOpts.call(this);
    this.addOpts({
      data: {
        check: "PlainObject",
        "default": {}
      },
      onDataChanged: {
        check: Function,
        "default": function() {}
      }
    });
  };

  MapConfigurationEditor.prototype.readOpts = function() {
    MapConfigurationEditor.__super__.readOpts.call(this);
    if (!this._data.center) {
      this._data.center = {
        lat: 0,
        lng: 0
      };
    }
    if (this._data.zoom == null) {
      this._data.zoom = 2;
    }
  };

  function MapConfigurationEditor(opts) {
    MapConfigurationEditor.__super__.constructor.call(this, opts);
    this.__init();
    this.__initMap();
  }

  MapConfigurationEditor.prototype.__init = function() {
    return this.__layout = new CUI.VerticalLayout({
      top: {
        content: new CUI.Label({
          text: $$("geo_json.objecttype.map_config.title"),
          "class": "ez5-map-config-title"
        })
      },
      center: {
        content: this.__createMapContainer()
      }
    });
  };

  MapConfigurationEditor.prototype.getElement = function() {
    return this.__layout.DOM;
  };

  MapConfigurationEditor.prototype.__createMapContainer = function() {
    this.__mapContainer = CUI.dom.div("ez5-map-config-container");
    CUI.dom.setStyle(this.__mapContainer, {
      height: "300px",
      width: "300px"
    });
    return this.__mapContainer;
  };

  MapConfigurationEditor.prototype.__initMap = function() {
    var mapOpts;
    if (CUI.util.isArray(this._data.center)) {
      this._data.center = {
        lat: this._data.center[0],
        lng: this._data.center[1]
      };
    }
    this._data.zoom = Math.round(this._data.zoom);
    mapOpts = {
      centerPosition: this._data.center,
      zoom: this._data.zoom,
      clickable: false,
      tilesSelector: false,
      searchInput: false,
      onMoveEnd: (function(_this) {
        return function() {
          return _this.__saveCurrentView();
        };
      })(this),
      onZoomEnd: (function(_this) {
        return function() {
          return _this.__saveCurrentView();
        };
      })(this)
    };
    return GeoJsonMap.load(mapOpts).done((function(_this) {
      return function(map) {
        _this.__map = map;
        CUI.dom.append(_this.__mapContainer, _this.__map);
        return _this.__map.resize();
      };
    })(this)).fail((function(_this) {
      return function(err) {
        return console.error("Failed to load map:", err);
      };
    })(this));
  };

  MapConfigurationEditor.prototype.__saveCurrentView = function() {
    if (!this.__map) {
      return;
    }
    this._data.center = this.__map.getCenter();
    this._data.zoom = Math.round(this.__map.getZoom());
    return this._onDataChanged();
  };

  MapConfigurationEditor.prototype.destroy = function() {
    var ref;
    if ((ref = this.__map) != null) {
      ref.destroy();
    }
    return MapConfigurationEditor.__super__.destroy.call(this);
  };

  return MapConfigurationEditor;

})(CUI.Element);
// Generated by CoffeeScript 1.12.7
var GeoJsonObjecttypePlugin,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

GeoJsonObjecttypePlugin = (function(superClass) {
  extend(GeoJsonObjecttypePlugin, superClass);

  function GeoJsonObjecttypePlugin() {
    return GeoJsonObjecttypePlugin.__super__.constructor.apply(this, arguments);
  }

  GeoJsonObjecttypePlugin.prototype.__hasGeoJsonFields = function() {
    var checkField, ot_fields;
    this.otm = new ObjecttypeManager();
    this.otm.addObjecttypes((function(_this) {
      return function(table) {
        return table.name() === _this._objecttypeListViewItem.objecttype.name();
      };
    })(this));
    ot_fields = this.otm.getAllFields();
    checkField = (function(_this) {
      return function(field) {
        if (field instanceof GeoJsonColumn) {
          return true;
        }
        if (field instanceof CustomDataType && (typeof field.supportsGeoStandard === "function" ? field.supportsGeoStandard() : void 0)) {
          return true;
        }
        return false;
      };
    })(this);
    return ot_fields.some((function(_this) {
      return function(field) {
        return checkField(field);
      };
    })(this));
  };

  GeoJsonObjecttypePlugin.prototype.getTab = function() {
    var tab;
    if (!ez5.session.getCapability("geo_support")) {
      return;
    }
    if (!this.__hasGeoJsonFields()) {
      return;
    }
    tab = {
      padded: false,
      name: "geo_json",
      text: $$("admin.objecttype.tab.geo_json"),
      content: (function(_this) {
        return function() {
          return _this.__renderGeoJsonTab();
        };
      })(this)
    };
    return tab;
  };

  GeoJsonObjecttypePlugin.prototype.onLoad = function() {
    var data;
    data = this.__getData();
    if (!data.objecttype.custom_data.webfrontend) {
      data.objecttype.custom_data.webfrontend = {};
    }
    if (!data.objecttype.custom_data.webfrontend.geo_json) {
      data.objecttype.custom_data.webfrontend.geo_json = {};
    }
  };

  GeoJsonObjecttypePlugin.prototype.getSaveData = function(saveData) {
    var base, base1;
    if ((base = saveData.objecttype.custom_data).webfrontend == null) {
      base.webfrontend = {};
    }
    if ((base1 = saveData.objecttype.custom_data.webfrontend).geo_json == null) {
      base1.geo_json = {};
    }
    saveData.objecttype.custom_data.webfrontend.geo_json = CUI.util.copyObjectV2(this.__getData().objecttype.custom_data.webfrontend.geo_json, true);
  };

  GeoJsonObjecttypePlugin.prototype.__renderGeoJsonTab = function() {
    var data, form;
    data = this.__getData().objecttype.custom_data.webfrontend.geo_json;
    form = new CUI.Form({
      data: data,
      fields: this.__getFormFields(data)
    });
    return form.start();
  };

  GeoJsonObjecttypePlugin.prototype.__getFormFields = function(data) {
    var fields;
    fields = [
      {
        type: CUI.Checkbox,
        name: "enabled",
        text: $$("geo_json.objecttype.enabled.text"),
        form: {
          label: $$("geo_json.objecttype.enabled.label")
        },
        onDataChanged: (function(_this) {
          return function(data, field) {
            var i, j, k, len, len1, ref, ref1, results, results1;
            if (data.enabled) {
              ref = ["marker_icon", "marker_color", "default_view.enabled", "default_view"];
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                k = ref[i];
                results.push(field.getForm().getFieldsByName(k)[0].enable());
              }
              return results;
            } else {
              ref1 = ["marker_icon", "marker_color", "default_view.enabled", "default_view"];
              results1 = [];
              for (j = 0, len1 = ref1.length; j < len1; j++) {
                k = ref1[j];
                results1.push(field.getForm().getFieldsByName(k)[0].disable());
              }
              return results1;
            }
          };
        })(this)
      }, {
        type: CUI.IconInput,
        name: "marker_icon",
        disabled: (function(_this) {
          return function() {
            return !data.enabled;
          };
        })(this),
        form: {
          label: $$("geo_json.objecttype.marker_icon.label"),
          hint: $$("geo_json.objecttype.marker_icon.hint")
        }
      }, {
        type: CUI.ColorInput,
        name: "marker_color",
        disabled: (function(_this) {
          return function() {
            return !data.enabled;
          };
        })(this),
        form: {
          label: $$("geo_json.objecttype.marker_color.label"),
          hint: $$("geo_json.objecttype.marker_color.hint")
        }
      }, {
        type: CUI.Checkbox,
        name: "default_view.enabled",
        disabled: (function(_this) {
          return function() {
            return !data.enabled;
          };
        })(this),
        form: {
          label: $$("geo_json.objecttype.default_view.enable")
        }
      }, {
        type: CUI.DataFieldProxy,
        call_others: false,
        name: "default_view",
        disabled: (function(_this) {
          return function() {
            return !data.enabled;
          };
        })(this),
        element: (function(_this) {
          return function(dataField) {
            return _this.__createMapConfigurationEditor(dataField);
          };
        })(this)
      }
    ];
    return fields;
  };

  GeoJsonObjecttypePlugin.prototype.__createMapConfigurationEditor = function(dataField) {
    var container, data, mapEditor;
    data = dataField.getData() || {
      enabled: false,
      center: {
        lat: 0,
        lng: 0
      },
      zoom: 2
    };
    container = new CUI.VerticalLayout();
    if (data.enabled) {
      mapEditor = new MapConfigurationEditor({
        data: data,
        onDataChanged: (function(_this) {
          return function() {
            return CUI.Events.trigger({
              type: "data-changed",
              node: dataField
            });
          };
        })(this)
      });
      container.append(mapEditor.getElement(), "center");
    }
    return container;
  };

  return GeoJsonObjecttypePlugin;

})(ez5.ObjecttypePlugin);

Objecttype.plugins.registerPlugin(GeoJsonObjecttypePlugin);
